"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkfront_end"] = self["webpackChunkfront_end"] || []).push([["vendors-node_modules_devexpress_dx-grid-core_dist_dx-grid-core_es_js"],{

/***/ "./node_modules/@devexpress/dx-grid-core/dist/dx-grid-core.es.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@devexpress/dx-grid-core/dist/dx-grid-core.es.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BAND_DUPLICATE_RENDER\": function() { return /* binding */ BAND_DUPLICATE_RENDER; },\n/* harmony export */   \"BAND_EMPTY_CELL\": function() { return /* binding */ BAND_EMPTY_CELL; },\n/* harmony export */   \"BAND_FILL_LEVEL_CELL\": function() { return /* binding */ BAND_FILL_LEVEL_CELL; },\n/* harmony export */   \"BAND_GROUP_CELL\": function() { return /* binding */ BAND_GROUP_CELL; },\n/* harmony export */   \"BAND_HEADER_CELL\": function() { return /* binding */ BAND_HEADER_CELL; },\n/* harmony export */   \"BOTTOM_POSITION\": function() { return /* binding */ BOTTOM_POSITION; },\n/* harmony export */   \"DEFAULT_COLUMN_WIDTH\": function() { return /* binding */ DEFAULT_COLUMN_WIDTH; },\n/* harmony export */   \"DEFAULT_FILTER_OPERATIONS\": function() { return /* binding */ DEFAULT_FILTER_OPERATIONS; },\n/* harmony export */   \"FIXED_COLUMN_LEFT_SIDE\": function() { return /* binding */ FIXED_COLUMN_LEFT_SIDE; },\n/* harmony export */   \"FIXED_COLUMN_RIGHT_SIDE\": function() { return /* binding */ FIXED_COLUMN_RIGHT_SIDE; },\n/* harmony export */   \"GROUP_KEY_SEPARATOR\": function() { return /* binding */ GROUP_KEY_SEPARATOR; },\n/* harmony export */   \"ROOT_GROUP\": function() { return /* binding */ ROOT_GROUP; },\n/* harmony export */   \"TABLE_ADDED_TYPE\": function() { return /* binding */ TABLE_ADDED_TYPE; },\n/* harmony export */   \"TABLE_BAND_TYPE\": function() { return /* binding */ TABLE_BAND_TYPE; },\n/* harmony export */   \"TABLE_DATA_TYPE\": function() { return /* binding */ TABLE_DATA_TYPE; },\n/* harmony export */   \"TABLE_DETAIL_TYPE\": function() { return /* binding */ TABLE_DETAIL_TYPE; },\n/* harmony export */   \"TABLE_EDIT_COMMAND_TYPE\": function() { return /* binding */ TABLE_EDIT_COMMAND_TYPE; },\n/* harmony export */   \"TABLE_EDIT_TYPE\": function() { return /* binding */ TABLE_EDIT_TYPE; },\n/* harmony export */   \"TABLE_FILTER_TYPE\": function() { return /* binding */ TABLE_FILTER_TYPE; },\n/* harmony export */   \"TABLE_FIXED_TYPE\": function() { return /* binding */ TABLE_FIXED_TYPE; },\n/* harmony export */   \"TABLE_FLEX_TYPE\": function() { return /* binding */ TABLE_FLEX_TYPE; },\n/* harmony export */   \"TABLE_GROUP_SUMMARY_TYPE\": function() { return /* binding */ TABLE_GROUP_SUMMARY_TYPE; },\n/* harmony export */   \"TABLE_GROUP_TYPE\": function() { return /* binding */ TABLE_GROUP_TYPE; },\n/* harmony export */   \"TABLE_HEADING_TYPE\": function() { return /* binding */ TABLE_HEADING_TYPE; },\n/* harmony export */   \"TABLE_NODATA_TYPE\": function() { return /* binding */ TABLE_NODATA_TYPE; },\n/* harmony export */   \"TABLE_REORDERING_TYPE\": function() { return /* binding */ TABLE_REORDERING_TYPE; },\n/* harmony export */   \"TABLE_SELECT_TYPE\": function() { return /* binding */ TABLE_SELECT_TYPE; },\n/* harmony export */   \"TABLE_STUB_TYPE\": function() { return /* binding */ TABLE_STUB_TYPE; },\n/* harmony export */   \"TABLE_TOTAL_SUMMARY_TYPE\": function() { return /* binding */ TABLE_TOTAL_SUMMARY_TYPE; },\n/* harmony export */   \"TABLE_TREE_SUMMARY_TYPE\": function() { return /* binding */ TABLE_TREE_SUMMARY_TYPE; },\n/* harmony export */   \"TOP_POSITION\": function() { return /* binding */ TOP_POSITION; },\n/* harmony export */   \"addRow\": function() { return /* binding */ addRow; },\n/* harmony export */   \"addedRowsByIds\": function() { return /* binding */ addedRowsByIds; },\n/* harmony export */   \"adjustSortIndex\": function() { return /* binding */ adjustSortIndex; },\n/* harmony export */   \"allSelected\": function() { return /* binding */ allSelected; },\n/* harmony export */   \"bandLevelsVisibility\": function() { return /* binding */ bandLevelsVisibility; },\n/* harmony export */   \"buildGroupTree\": function() { return /* binding */ buildGroupTree; },\n/* harmony export */   \"calculateBand\": function() { return /* binding */ calculateBand; },\n/* harmony export */   \"calculateFixedColumnProps\": function() { return /* binding */ calculateFixedColumnProps; },\n/* harmony export */   \"calculateGroupCellIndent\": function() { return /* binding */ calculateGroupCellIndent; },\n/* harmony export */   \"calculateKeepOther\": function() { return /* binding */ calculateKeepOther; },\n/* harmony export */   \"calculateRequestedRange\": function() { return /* binding */ calculateRequestedRange; },\n/* harmony export */   \"calculateScrollHeight\": function() { return /* binding */ calculateScrollHeight; },\n/* harmony export */   \"calculateStartPage\": function() { return /* binding */ calculateStartPage; },\n/* harmony export */   \"cancelAddedRows\": function() { return /* binding */ cancelAddedRows; },\n/* harmony export */   \"cancelChanges\": function() { return /* binding */ cancelChanges; },\n/* harmony export */   \"cancelColumnGroupingDraft\": function() { return /* binding */ cancelColumnGroupingDraft; },\n/* harmony export */   \"cancelDeletedRows\": function() { return /* binding */ cancelDeletedRows; },\n/* harmony export */   \"cancelTableColumnWidthDraft\": function() { return /* binding */ cancelTableColumnWidthDraft; },\n/* harmony export */   \"cellValueGetter\": function() { return /* binding */ cellValueGetter; },\n/* harmony export */   \"changeAddedRow\": function() { return /* binding */ changeAddedRow; },\n/* harmony export */   \"changeColumnFilter\": function() { return /* binding */ changeColumnFilter; },\n/* harmony export */   \"changeColumnGrouping\": function() { return /* binding */ changeColumnGrouping; },\n/* harmony export */   \"changeColumnOrder\": function() { return /* binding */ changeColumnOrder; },\n/* harmony export */   \"changeColumnSorting\": function() { return /* binding */ changeColumnSorting; },\n/* harmony export */   \"changeRow\": function() { return /* binding */ changeRow; },\n/* harmony export */   \"changeSearchValue\": function() { return /* binding */ changeSearchValue; },\n/* harmony export */   \"changeTableColumnWidth\": function() { return /* binding */ changeTableColumnWidth; },\n/* harmony export */   \"changedRowsByIds\": function() { return /* binding */ changedRowsByIds; },\n/* harmony export */   \"checkColumnWidths\": function() { return /* binding */ checkColumnWidths; },\n/* harmony export */   \"checkTableColumnExtensions\": function() { return /* binding */ checkTableColumnExtensions; },\n/* harmony export */   \"clamp\": function() { return /* binding */ clamp; },\n/* harmony export */   \"closeGroupGetter\": function() { return /* binding */ closeGroupGetter; },\n/* harmony export */   \"closeSheet\": function() { return /* binding */ closeSheet; },\n/* harmony export */   \"collapsedTreeRowsGetter\": function() { return /* binding */ collapsedTreeRowsGetter; },\n/* harmony export */   \"columnBandLevels\": function() { return /* binding */ columnBandLevels; },\n/* harmony export */   \"columnChooserItems\": function() { return /* binding */ columnChooserItems; },\n/* harmony export */   \"columnVisibleIntervals\": function() { return /* binding */ columnVisibleIntervals; },\n/* harmony export */   \"columnsWithEditingCells\": function() { return /* binding */ columnsWithEditingCells; },\n/* harmony export */   \"convertWidth\": function() { return /* binding */ convertWidth; },\n/* harmony export */   \"createRowChangeGetter\": function() { return /* binding */ createRowChangeGetter; },\n/* harmony export */   \"currentPage\": function() { return /* binding */ currentPage; },\n/* harmony export */   \"customGroupedRows\": function() { return /* binding */ customGroupedRows; },\n/* harmony export */   \"customGroupingRowIdGetter\": function() { return /* binding */ customGroupingRowIdGetter; },\n/* harmony export */   \"customTreeRowIdGetter\": function() { return /* binding */ customTreeRowIdGetter; },\n/* harmony export */   \"customTreeRowLevelKeyGetter\": function() { return /* binding */ customTreeRowLevelKeyGetter; },\n/* harmony export */   \"customTreeRowsWithMeta\": function() { return /* binding */ customTreeRowsWithMeta; },\n/* harmony export */   \"defaultFilterPredicate\": function() { return /* binding */ defaultFilterPredicate; },\n/* harmony export */   \"defaultFormatlessSummaries\": function() { return /* binding */ defaultFormatlessSummaries; },\n/* harmony export */   \"defaultSummaryCalculator\": function() { return /* binding */ defaultSummaryCalculator; },\n/* harmony export */   \"deleteRows\": function() { return /* binding */ deleteRows; },\n/* harmony export */   \"draftColumnGrouping\": function() { return /* binding */ draftColumnGrouping; },\n/* harmony export */   \"draftOrder\": function() { return /* binding */ draftOrder; },\n/* harmony export */   \"draftTableColumnWidth\": function() { return /* binding */ draftTableColumnWidth; },\n/* harmony export */   \"emptyViewport\": function() { return /* binding */ emptyViewport; },\n/* harmony export */   \"emptyVirtualRows\": function() { return /* binding */ emptyVirtualRows; },\n/* harmony export */   \"evalAnimations\": function() { return /* binding */ evalAnimations; },\n/* harmony export */   \"expandedGroupRows\": function() { return /* binding */ expandedGroupRows; },\n/* harmony export */   \"expandedTreeRows\": function() { return /* binding */ expandedTreeRows; },\n/* harmony export */   \"exportHeader\": function() { return /* binding */ exportHeader; },\n/* harmony export */   \"exportRows\": function() { return /* binding */ exportRows; },\n/* harmony export */   \"exportSummaryGetter\": function() { return /* binding */ exportSummaryGetter; },\n/* harmony export */   \"exportSummaryItems\": function() { return /* binding */ exportSummaryItems; },\n/* harmony export */   \"filterActiveAnimations\": function() { return /* binding */ filterActiveAnimations; },\n/* harmony export */   \"filterExpression\": function() { return /* binding */ filterExpression; },\n/* harmony export */   \"filteredCollapsedRowsGetter\": function() { return /* binding */ filteredCollapsedRowsGetter; },\n/* harmony export */   \"filteredRows\": function() { return /* binding */ filteredRows; },\n/* harmony export */   \"findChainByColumnIndex\": function() { return /* binding */ findChainByColumnIndex; },\n/* harmony export */   \"findRanges\": function() { return /* binding */ findRanges; },\n/* harmony export */   \"firstRowOnPage\": function() { return /* binding */ firstRowOnPage; },\n/* harmony export */   \"generateSimpleChains\": function() { return /* binding */ generateSimpleChains; },\n/* harmony export */   \"getAnimations\": function() { return /* binding */ getAnimations; },\n/* harmony export */   \"getAvailableFilterOperationsGetter\": function() { return /* binding */ getAvailableFilterOperationsGetter; },\n/* harmony export */   \"getAvailableRowCount\": function() { return /* binding */ getAvailableRowCount; },\n/* harmony export */   \"getBandComponent\": function() { return /* binding */ getBandComponent; },\n/* harmony export */   \"getCellGeometries\": function() { return /* binding */ getCellGeometries; },\n/* harmony export */   \"getCollapsedGrid\": function() { return /* binding */ getCollapsedGrid; },\n/* harmony export */   \"getCollapsedGrids\": function() { return /* binding */ getCollapsedGrids; },\n/* harmony export */   \"getColumnBoundaries\": function() { return /* binding */ getColumnBoundaries; },\n/* harmony export */   \"getColumnExtension\": function() { return /* binding */ getColumnExtension; },\n/* harmony export */   \"getColumnExtensionValueGetter\": function() { return /* binding */ getColumnExtensionValueGetter; },\n/* harmony export */   \"getColumnFilterConfig\": function() { return /* binding */ getColumnFilterConfig; },\n/* harmony export */   \"getColumnFilterOperations\": function() { return /* binding */ getColumnFilterOperations; },\n/* harmony export */   \"getColumnMeta\": function() { return /* binding */ getColumnMeta; },\n/* harmony export */   \"getColumnSizes\": function() { return /* binding */ getColumnSizes; },\n/* harmony export */   \"getColumnSortingDirection\": function() { return /* binding */ getColumnSortingDirection; },\n/* harmony export */   \"getColumnSummaries\": function() { return /* binding */ getColumnSummaries; },\n/* harmony export */   \"getColumnWidthGetter\": function() { return /* binding */ getColumnWidthGetter; },\n/* harmony export */   \"getColumnsRenderBoundary\": function() { return /* binding */ getColumnsRenderBoundary; },\n/* harmony export */   \"getFixedColumnKeys\": function() { return /* binding */ getFixedColumnKeys; },\n/* harmony export */   \"getForceReloadInterval\": function() { return /* binding */ getForceReloadInterval; },\n/* harmony export */   \"getGroupCellTargetIndex\": function() { return /* binding */ getGroupCellTargetIndex; },\n/* harmony export */   \"getGroupInlineSummaries\": function() { return /* binding */ getGroupInlineSummaries; },\n/* harmony export */   \"getNextColumnName\": function() { return /* binding */ getNextColumnName; },\n/* harmony export */   \"getPersistentSortedColumns\": function() { return /* binding */ getPersistentSortedColumns; },\n/* harmony export */   \"getReferenceIndex\": function() { return /* binding */ getReferenceIndex; },\n/* harmony export */   \"getRequestMeta\": function() { return /* binding */ getRequestMeta; },\n/* harmony export */   \"getRowChange\": function() { return /* binding */ getRowChange; },\n/* harmony export */   \"getRowsRenderBoundary\": function() { return /* binding */ getRowsRenderBoundary; },\n/* harmony export */   \"getRowsVisibleBoundary\": function() { return /* binding */ getRowsVisibleBoundary; },\n/* harmony export */   \"getScrollTop\": function() { return /* binding */ getScrollTop; },\n/* harmony export */   \"getSelectedFilterOperation\": function() { return /* binding */ getSelectedFilterOperation; },\n/* harmony export */   \"getTableColumnGeometries\": function() { return /* binding */ getTableColumnGeometries; },\n/* harmony export */   \"getTableTargetColumnIndex\": function() { return /* binding */ getTableTargetColumnIndex; },\n/* harmony export */   \"getTopRowId\": function() { return /* binding */ getTopRowId; },\n/* harmony export */   \"getTreeRowLevelGetter\": function() { return /* binding */ getTreeRowLevelGetter; },\n/* harmony export */   \"getViewport\": function() { return /* binding */ getViewport; },\n/* harmony export */   \"groupCollapsedRowsGetter\": function() { return /* binding */ groupCollapsedRowsGetter; },\n/* harmony export */   \"groupFooterSummaryExists\": function() { return /* binding */ groupFooterSummaryExists; },\n/* harmony export */   \"groupOutlineLevels\": function() { return /* binding */ groupOutlineLevels; },\n/* harmony export */   \"groupRowChecker\": function() { return /* binding */ groupRowChecker; },\n/* harmony export */   \"groupRowLevelKeyGetter\": function() { return /* binding */ groupRowLevelKeyGetter; },\n/* harmony export */   \"groupSummaryValues\": function() { return /* binding */ groupSummaryValues; },\n/* harmony export */   \"groupedRows\": function() { return /* binding */ groupedRows; },\n/* harmony export */   \"groupingPanelItems\": function() { return /* binding */ groupingPanelItems; },\n/* harmony export */   \"intervalUtil\": function() { return /* binding */ intervalUtil; },\n/* harmony export */   \"isAddedTableRow\": function() { return /* binding */ isAddedTableRow; },\n/* harmony export */   \"isBandedOrHeaderRow\": function() { return /* binding */ isBandedOrHeaderRow; },\n/* harmony export */   \"isBandedTableRow\": function() { return /* binding */ isBandedTableRow; },\n/* harmony export */   \"isDataTableCell\": function() { return /* binding */ isDataTableCell; },\n/* harmony export */   \"isDataTableRow\": function() { return /* binding */ isDataTableRow; },\n/* harmony export */   \"isDetailRowExpanded\": function() { return /* binding */ isDetailRowExpanded; },\n/* harmony export */   \"isDetailTableCell\": function() { return /* binding */ isDetailTableCell; },\n/* harmony export */   \"isDetailTableRow\": function() { return /* binding */ isDetailTableRow; },\n/* harmony export */   \"isDetailToggleTableCell\": function() { return /* binding */ isDetailToggleTableCell; },\n/* harmony export */   \"isEditCommandsTableCell\": function() { return /* binding */ isEditCommandsTableCell; },\n/* harmony export */   \"isEditTableCell\": function() { return /* binding */ isEditTableCell; },\n/* harmony export */   \"isEditTableRow\": function() { return /* binding */ isEditTableRow; },\n/* harmony export */   \"isFilterTableCell\": function() { return /* binding */ isFilterTableCell; },\n/* harmony export */   \"isFilterTableRow\": function() { return /* binding */ isFilterTableRow; },\n/* harmony export */   \"isFilterValueEmpty\": function() { return /* binding */ isFilterValueEmpty; },\n/* harmony export */   \"isFixedTableRow\": function() { return /* binding */ isFixedTableRow; },\n/* harmony export */   \"isFooterSummary\": function() { return /* binding */ isFooterSummary; },\n/* harmony export */   \"isGroupIndentStubTableCell\": function() { return /* binding */ isGroupIndentStubTableCell; },\n/* harmony export */   \"isGroupIndentTableCell\": function() { return /* binding */ isGroupIndentTableCell; },\n/* harmony export */   \"isGroupRowOrdinaryCell\": function() { return /* binding */ isGroupRowOrdinaryCell; },\n/* harmony export */   \"isGroupSummaryTableCell\": function() { return /* binding */ isGroupSummaryTableCell; },\n/* harmony export */   \"isGroupSummaryTableRow\": function() { return /* binding */ isGroupSummaryTableRow; },\n/* harmony export */   \"isGroupTableCell\": function() { return /* binding */ isGroupTableCell; },\n/* harmony export */   \"isGroupTableRow\": function() { return /* binding */ isGroupTableRow; },\n/* harmony export */   \"isHeaderStubTableCell\": function() { return /* binding */ isHeaderStubTableCell; },\n/* harmony export */   \"isHeadingEditCommandsTableCell\": function() { return /* binding */ isHeadingEditCommandsTableCell; },\n/* harmony export */   \"isHeadingTableCell\": function() { return /* binding */ isHeadingTableCell; },\n/* harmony export */   \"isHeadingTableRow\": function() { return /* binding */ isHeadingTableRow; },\n/* harmony export */   \"isInlineGroupCaptionSummary\": function() { return /* binding */ isInlineGroupCaptionSummary; },\n/* harmony export */   \"isNoDataColumn\": function() { return /* binding */ isNoDataColumn; },\n/* harmony export */   \"isNoDataTableCell\": function() { return /* binding */ isNoDataTableCell; },\n/* harmony export */   \"isNoDataTableRow\": function() { return /* binding */ isNoDataTableRow; },\n/* harmony export */   \"isPreviousCellContainSummary\": function() { return /* binding */ isPreviousCellContainSummary; },\n/* harmony export */   \"isRowHighlighted\": function() { return /* binding */ isRowHighlighted; },\n/* harmony export */   \"isRowSummaryCell\": function() { return /* binding */ isRowSummaryCell; },\n/* harmony export */   \"isSelectAllTableCell\": function() { return /* binding */ isSelectAllTableCell; },\n/* harmony export */   \"isSelectTableCell\": function() { return /* binding */ isSelectTableCell; },\n/* harmony export */   \"isStubTableCell\": function() { return /* binding */ isStubTableCell; },\n/* harmony export */   \"isTotalSummaryTableCell\": function() { return /* binding */ isTotalSummaryTableCell; },\n/* harmony export */   \"isTotalSummaryTableRow\": function() { return /* binding */ isTotalSummaryTableRow; },\n/* harmony export */   \"isTreeRowLeafGetter\": function() { return /* binding */ isTreeRowLeafGetter; },\n/* harmony export */   \"isTreeSummaryTableCell\": function() { return /* binding */ isTreeSummaryTableCell; },\n/* harmony export */   \"isTreeSummaryTableRow\": function() { return /* binding */ isTreeSummaryTableRow; },\n/* harmony export */   \"isTreeTableCell\": function() { return /* binding */ isTreeTableCell; },\n/* harmony export */   \"isValidValue\": function() { return /* binding */ isValidValue; },\n/* harmony export */   \"lastRowOnPage\": function() { return /* binding */ lastRowOnPage; },\n/* harmony export */   \"loadedRowsStart\": function() { return /* binding */ loadedRowsStart; },\n/* harmony export */   \"maximumGroupLevel\": function() { return /* binding */ maximumGroupLevel; },\n/* harmony export */   \"mergeRows\": function() { return /* binding */ mergeRows; },\n/* harmony export */   \"needFetchMorePages\": function() { return /* binding */ needFetchMorePages; },\n/* harmony export */   \"normalizeRanges\": function() { return /* binding */ normalizeRanges; },\n/* harmony export */   \"orderedColumns\": function() { return /* binding */ orderedColumns; },\n/* harmony export */   \"pageCount\": function() { return /* binding */ pageCount; },\n/* harmony export */   \"paginatedRows\": function() { return /* binding */ paginatedRows; },\n/* harmony export */   \"plainRows\": function() { return /* binding */ plainRows; },\n/* harmony export */   \"prepareGroupSummaryItems\": function() { return /* binding */ prepareGroupSummaryItems; },\n/* harmony export */   \"recalculateBounds\": function() { return /* binding */ recalculateBounds; },\n/* harmony export */   \"removeEmptyGroups\": function() { return /* binding */ removeEmptyGroups; },\n/* harmony export */   \"rowCount\": function() { return /* binding */ rowCount; },\n/* harmony export */   \"rowIdGetter\": function() { return /* binding */ rowIdGetter; },\n/* harmony export */   \"rowToPageIndex\": function() { return /* binding */ rowToPageIndex; },\n/* harmony export */   \"rowsToExport\": function() { return /* binding */ rowsToExport; },\n/* harmony export */   \"rowsWithAvailableToSelect\": function() { return /* binding */ rowsWithAvailableToSelect; },\n/* harmony export */   \"rowsWithEditingCells\": function() { return /* binding */ rowsWithEditingCells; },\n/* harmony export */   \"rowsWithPageHeaders\": function() { return /* binding */ rowsWithPageHeaders; },\n/* harmony export */   \"searchFilterExpression\": function() { return /* binding */ searchFilterExpression; },\n/* harmony export */   \"setCurrentPage\": function() { return /* binding */ setCurrentPage; },\n/* harmony export */   \"setPageSize\": function() { return /* binding */ setPageSize; },\n/* harmony export */   \"shouldSendRequest\": function() { return /* binding */ shouldSendRequest; },\n/* harmony export */   \"someSelected\": function() { return /* binding */ someSelected; },\n/* harmony export */   \"sortAndSpliceColumns\": function() { return /* binding */ sortAndSpliceColumns; },\n/* harmony export */   \"sortedRows\": function() { return /* binding */ sortedRows; },\n/* harmony export */   \"splitHeaderColumnChains\": function() { return /* binding */ splitHeaderColumnChains; },\n/* harmony export */   \"startEditCells\": function() { return /* binding */ startEditCells; },\n/* harmony export */   \"startEditRows\": function() { return /* binding */ startEditRows; },\n/* harmony export */   \"stopEditCells\": function() { return /* binding */ stopEditCells; },\n/* harmony export */   \"stopEditRows\": function() { return /* binding */ stopEditRows; },\n/* harmony export */   \"tableCellColSpanGetter\": function() { return /* binding */ tableCellColSpanGetter; },\n/* harmony export */   \"tableColumnsWithDataRows\": function() { return /* binding */ tableColumnsWithDataRows; },\n/* harmony export */   \"tableColumnsWithDetail\": function() { return /* binding */ tableColumnsWithDetail; },\n/* harmony export */   \"tableColumnsWithDraftWidths\": function() { return /* binding */ tableColumnsWithDraftWidths; },\n/* harmony export */   \"tableColumnsWithEditing\": function() { return /* binding */ tableColumnsWithEditing; },\n/* harmony export */   \"tableColumnsWithFixed\": function() { return /* binding */ tableColumnsWithFixed; },\n/* harmony export */   \"tableColumnsWithGrouping\": function() { return /* binding */ tableColumnsWithGrouping; },\n/* harmony export */   \"tableColumnsWithSelection\": function() { return /* binding */ tableColumnsWithSelection; },\n/* harmony export */   \"tableColumnsWithWidths\": function() { return /* binding */ tableColumnsWithWidths; },\n/* harmony export */   \"tableDataColumnsExist\": function() { return /* binding */ tableDataColumnsExist; },\n/* harmony export */   \"tableDetailCellColSpanGetter\": function() { return /* binding */ tableDetailCellColSpanGetter; },\n/* harmony export */   \"tableGroupCellColSpanGetter\": function() { return /* binding */ tableGroupCellColSpanGetter; },\n/* harmony export */   \"tableHeaderColumnChainsWithBands\": function() { return /* binding */ tableHeaderColumnChainsWithBands; },\n/* harmony export */   \"tableHeaderColumnChainsWithFixed\": function() { return /* binding */ tableHeaderColumnChainsWithFixed; },\n/* harmony export */   \"tableHeaderRowsWithFilter\": function() { return /* binding */ tableHeaderRowsWithFilter; },\n/* harmony export */   \"tableHeaderRowsWithFixed\": function() { return /* binding */ tableHeaderRowsWithFixed; },\n/* harmony export */   \"tableHeaderRowsWithReordering\": function() { return /* binding */ tableHeaderRowsWithReordering; },\n/* harmony export */   \"tableRowsWithBands\": function() { return /* binding */ tableRowsWithBands; },\n/* harmony export */   \"tableRowsWithDataRows\": function() { return /* binding */ tableRowsWithDataRows; },\n/* harmony export */   \"tableRowsWithEditing\": function() { return /* binding */ tableRowsWithEditing; },\n/* harmony export */   \"tableRowsWithExpandedDetail\": function() { return /* binding */ tableRowsWithExpandedDetail; },\n/* harmony export */   \"tableRowsWithGrouping\": function() { return /* binding */ tableRowsWithGrouping; },\n/* harmony export */   \"tableRowsWithHeading\": function() { return /* binding */ tableRowsWithHeading; },\n/* harmony export */   \"tableRowsWithSummaries\": function() { return /* binding */ tableRowsWithSummaries; },\n/* harmony export */   \"tableRowsWithTotalSummaries\": function() { return /* binding */ tableRowsWithTotalSummaries; },\n/* harmony export */   \"toggleColumn\": function() { return /* binding */ toggleColumn; },\n/* harmony export */   \"toggleDetailRowExpanded\": function() { return /* binding */ toggleDetailRowExpanded; },\n/* harmony export */   \"toggleExpandedGroups\": function() { return /* binding */ toggleExpandedGroups; },\n/* harmony export */   \"toggleRowExpanded\": function() { return /* binding */ toggleRowExpanded; },\n/* harmony export */   \"toggleSelection\": function() { return /* binding */ toggleSelection; },\n/* harmony export */   \"totalSummaryValues\": function() { return /* binding */ totalSummaryValues; },\n/* harmony export */   \"treeSummaryValues\": function() { return /* binding */ treeSummaryValues; },\n/* harmony export */   \"trimRowsToInterval\": function() { return /* binding */ trimRowsToInterval; },\n/* harmony export */   \"unwrapSelectedRows\": function() { return /* binding */ unwrapSelectedRows; },\n/* harmony export */   \"unwrappedCustomTreeRows\": function() { return /* binding */ unwrappedCustomTreeRows; },\n/* harmony export */   \"unwrappedFilteredRows\": function() { return /* binding */ unwrappedFilteredRows; },\n/* harmony export */   \"virtualRowsWithCache\": function() { return /* binding */ virtualRowsWithCache; },\n/* harmony export */   \"visibleTableColumns\": function() { return /* binding */ visibleTableColumns; }\n/* harmony export */ });\n/* harmony import */ var _devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @devexpress/dx-core */ \"./node_modules/@devexpress/dx-core/dist/dx-core.es.js\");\n/**\n * Bundle of @devexpress/dx-grid-core\n * Generated: 2021-06-24\n * Version: 2.7.6\n * License: https://js.devexpress.com/Licensing\n */\n\n\n\nvar GRID_GROUP_TYPE = Symbol('group');\r\nvar GRID_GROUP_CHECK = Symbol(GRID_GROUP_TYPE.toString() + \"_check\");\r\nvar GRID_GROUP_LEVEL_KEY = Symbol(GRID_GROUP_TYPE.toString() + \"_levelKey\");\r\nvar GRID_GROUP_COLLAPSED_ROWS = Symbol(GRID_GROUP_TYPE.toString() + \"_collapsedRows\");\n\nvar warnIfRowIdUndefined = function (getRowId) { return function (row) {\r\n    var result = getRowId(row);\r\n    if (!row[GRID_GROUP_CHECK] && result === undefined) {\r\n        // tslint:disable-next-line: no-console\r\n        console.warn('The row id is undefined. Check the getRowId function. The row is', row);\r\n    }\r\n    return result;\r\n}; };\r\nvar rowIdGetter = function (getRowId, rows) {\r\n    if (!getRowId) {\r\n        var map_1 = new Map(rows.map(function (row, rowIndex) { return [row, rowIndex]; }));\r\n        return function (row) { return map_1.get(row); };\r\n    }\r\n    return warnIfRowIdUndefined(getRowId);\r\n};\r\nvar defaultGetCellValue = function (row, columnName) { return row[columnName]; };\r\nvar cellValueGetter = function (getCellValue, columns) {\r\n    if (getCellValue === void 0) { getCellValue = defaultGetCellValue; }\r\n    var useFastAccessor = true;\r\n    var map = columns.reduce(function (acc, column) {\r\n        if (column.getCellValue) {\r\n            useFastAccessor = false;\r\n            acc[column.name] = column.getCellValue;\r\n        }\r\n        return acc;\r\n    }, {});\r\n    if (useFastAccessor) {\r\n        return getCellValue;\r\n    }\r\n    return function (row, columnName) { return (map[columnName]\r\n        ? map[columnName](row, columnName)\r\n        : getCellValue(row, columnName)); };\r\n};\n\nvar changeColumnSorting = function (state, _a) {\r\n    var columnName = _a.columnName, direction = _a.direction, keepOther = _a.keepOther, sortIndex = _a.sortIndex;\r\n    var sorting = state.sorting;\r\n    var nextSorting = [];\r\n    if (keepOther === true) {\r\n        nextSorting = sorting;\r\n    }\r\n    if (Array.isArray(keepOther)) {\r\n        nextSorting = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(sorting)\r\n            .filter(function (s) {\r\n            return keepOther.indexOf(s.columnName) > -1;\r\n        });\r\n    }\r\n    var columnSortingIndex = sorting.findIndex(function (s) { return s.columnName === columnName; });\r\n    var columnSorting = sorting[columnSortingIndex];\r\n    var newColumnSorting = {\r\n        columnName: columnName,\r\n        direction: direction\r\n            || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc'),\r\n    };\r\n    if (columnSortingIndex > -1) {\r\n        nextSorting = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(nextSorting);\r\n        nextSorting.splice(columnSortingIndex, 1);\r\n    }\r\n    if (direction !== null) {\r\n        var newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;\r\n        var newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;\r\n        nextSorting = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(nextSorting);\r\n        nextSorting.splice(newIndex, 0, newColumnSorting);\r\n    }\r\n    return {\r\n        sorting: nextSorting,\r\n    };\r\n};\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\nvar unique = function (arr) { return __spread(Array.from(new Set(arr))); };\r\nvar getColumnSortingDirection = function (sorting, columnName) {\r\n    var columnSorting = sorting.filter(function (s) { return s.columnName === columnName; })[0];\r\n    return columnSorting ? columnSorting.direction : null;\r\n};\r\nvar getPersistentSortedColumns = function (sorting, columnExtensions) {\r\n    if (columnExtensions === void 0) { columnExtensions = []; }\r\n    return columnExtensions.reduce(function (acc, _a) {\r\n        var columnName = _a.columnName, sortingEnabled = _a.sortingEnabled;\r\n        if (sortingEnabled === false) {\r\n            if (sorting.findIndex(function (sortItem) { return sortItem.columnName === columnName; }) > -1) {\r\n                acc.push(columnName);\r\n            }\r\n        }\r\n        return acc;\r\n    }, []);\r\n};\r\nvar calculateKeepOther = function (sorting, keepOther, persistentSortedColumns) {\r\n    if (persistentSortedColumns === void 0) { persistentSortedColumns = []; }\r\n    if (!persistentSortedColumns.length)\r\n        return keepOther;\r\n    if (!keepOther)\r\n        return persistentSortedColumns;\r\n    return Array.isArray(keepOther)\r\n        ? unique(__spread(keepOther, persistentSortedColumns))\r\n        : unique(__spread(sorting.map(function (item) { return item.columnName; }), persistentSortedColumns));\r\n};\n\n/* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */\r\n/* tslint:disable no-increment-decrement */\r\nvar merge = function (array, auxiliary, lo, mid, hi, compare) {\r\n    var i = lo;\r\n    var j = mid + 1;\r\n    var k = lo;\r\n    while (true) {\r\n        var cmp = compare(array[i], array[j]);\r\n        if (cmp <= 0) {\r\n            auxiliary[k++] = array[i++];\r\n            if (i > mid) {\r\n                do {\r\n                    auxiliary[k++] = array[j++];\r\n                } while (j <= hi);\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            auxiliary[k++] = array[j++];\r\n            if (j > hi) {\r\n                do {\r\n                    auxiliary[k++] = array[i++];\r\n                } while (i <= mid);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nvar sortArrayToAuxiliary = function (array, auxiliary, lo, hi, compare) {\r\n    if (hi < lo)\r\n        return;\r\n    if (hi === lo) {\r\n        auxiliary[lo] = array[lo];\r\n        return;\r\n    }\r\n    var mid = Math.floor(lo + ((hi - lo) / 2));\r\n    sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);\r\n    sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);\r\n    merge(array, auxiliary, lo, mid, hi, compare);\r\n};\r\nvar sortAuxiliaryToArray = function (array, auxiliary, lo, hi, compare) {\r\n    if (hi <= lo)\r\n        return;\r\n    var mid = Math.floor(lo + ((hi - lo) / 2));\r\n    sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);\r\n    sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);\r\n    merge(auxiliary, array, lo, mid, hi, compare);\r\n};\r\nvar mergeSort = (function (array, compare) {\r\n    if (compare === void 0) { compare = function (a, b) {\r\n        if (a < b)\r\n            return -1;\r\n        if (a > b)\r\n            return 1;\r\n        return 0;\r\n    }; }\r\n    var result = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(array);\r\n    var auxiliary = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(array);\r\n    sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);\r\n    return result;\r\n});\n\nvar NODE_CHECK = Symbol('node');\r\nvar rowsToTree = function (rows, getRowLevelKey) {\r\n    if (!rows.length)\r\n        return rows;\r\n    var levels = [{ children: [] }];\r\n    rows.forEach(function (row) {\r\n        var _a;\r\n        var levelKey = getRowLevelKey(row);\r\n        if (levelKey) {\r\n            var levelIndex = levels.slice(1)\r\n                .findIndex(function (level) { return getRowLevelKey(level.root) === levelKey; }) + 1;\r\n            if (levelIndex > 0) {\r\n                levels.splice(levelIndex, levels.length - levelIndex);\r\n            }\r\n            var node = (_a = {}, _a[NODE_CHECK] = true, _a.root = row, _a.children = [], _a);\r\n            levels[levels.length - 1].children.push(node);\r\n            levels.push(node);\r\n        }\r\n        else {\r\n            levels[levels.length - 1].children.push(row);\r\n        }\r\n    });\r\n    return levels[0].children;\r\n};\r\nvar treeToRows = function (tree, rows) {\r\n    if (rows === void 0) { rows = []; }\r\n    if (!tree.length)\r\n        return tree;\r\n    return tree.reduce(function (acc, node) {\r\n        if (node[NODE_CHECK]) {\r\n            acc.push(node.root);\r\n            treeToRows(node.children, rows);\r\n        }\r\n        else {\r\n            acc.push(node);\r\n        }\r\n        return acc;\r\n    }, rows);\r\n};\n\nvar defaultCompare = function (a, b) {\r\n    if (a === b)\r\n        return 0;\r\n    if (a === null) {\r\n        return b === undefined ? -1 : 1;\r\n    }\r\n    if (a === undefined) {\r\n        return 1;\r\n    }\r\n    if (b === null || b === undefined) {\r\n        return -1;\r\n    }\r\n    return a < b ? -1 : 1;\r\n};\r\nvar createCompare = function (sorting, getColumnCompare, getComparableValue) { return sorting.reduceRight(function (prevCompare, columnSorting) {\r\n    var columnName = columnSorting.columnName;\r\n    var inverse = columnSorting.direction === 'desc';\r\n    var columnCompare = (getColumnCompare && getColumnCompare(columnName)) || defaultCompare;\r\n    return function (aRow, bRow) {\r\n        var a = getComparableValue(aRow, columnName);\r\n        var b = getComparableValue(bRow, columnName);\r\n        var result = columnCompare(a, b);\r\n        if (result !== 0) {\r\n            return inverse ? -result : result;\r\n        }\r\n        return prevCompare(aRow, bRow);\r\n    };\r\n}, function () {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return 0;\r\n}); };\r\nvar sortTree = function (tree, compare) {\r\n    var sortedTree = tree.map(function (node) {\r\n        if (node[NODE_CHECK]) {\r\n            return __assign(__assign({}, node), { children: sortTree(node.children, compare) });\r\n        }\r\n        return node;\r\n    });\r\n    return mergeSort(sortedTree, function (a, b) { return compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b); });\r\n};\r\nvar sortHierarchicalRows = function (rows, compare, getRowLevelKey) {\r\n    var tree = rowsToTree(rows, getRowLevelKey);\r\n    var sortedTree = sortTree(tree, compare);\r\n    return treeToRows(sortedTree);\r\n};\r\nvar sortedRows = function (rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey) {\r\n    if (!sorting.length || !rows.length)\r\n        return rows;\r\n    var compare;\r\n    if (!getRowLevelKey) {\r\n        compare = createCompare(sorting, getColumnCompare, getCellValue);\r\n        return mergeSort(rows.slice(), compare);\r\n    }\r\n    compare = createCompare(sorting, getColumnCompare, function (row, columnName) {\r\n        if (isGroupRow && isGroupRow(row)) {\r\n            if (row.groupedBy === columnName) {\r\n                return row.value;\r\n            }\r\n            return undefined;\r\n        }\r\n        return getCellValue(row, columnName);\r\n    });\r\n    return sortHierarchicalRows(rows, compare, getRowLevelKey);\r\n};\n\nvar changeColumnFilter = function (filters, _a) {\r\n    var columnName = _a.columnName, config = _a.config;\r\n    var filterIndex = filters.findIndex(function (f) { return f.columnName === columnName; });\r\n    var nextState = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(filters);\r\n    if (config) {\r\n        var filter = __assign({ columnName: columnName }, config);\r\n        if (filterIndex > -1) {\r\n            nextState.splice(filterIndex, 1, filter);\r\n        }\r\n        else {\r\n            nextState.push(filter);\r\n        }\r\n    }\r\n    else if (filterIndex > -1) {\r\n        nextState.splice(filterIndex, 1);\r\n    }\r\n    return nextState;\r\n};\n\nvar getColumnFilterConfig = function (filters, columnName) { return (filters.length && filters.filter(function (s) { return s.columnName === columnName; })[0] || null); };\n\nvar filterExpression = function (filters, expression) {\r\n    // tslint:disable-next-line: no-object-literal-type-assertion\r\n    var selfFilterExpr = { filters: filters, operator: 'and' };\r\n    if (!expression) {\r\n        return selfFilterExpr;\r\n    }\r\n    return {\r\n        operator: 'and',\r\n        filters: [expression, selfFilterExpr],\r\n    };\r\n};\n\nvar operators = {\r\n    or: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc || predicate(row); }, false)); }; },\r\n    and: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc && predicate(row); }, true)); }; },\r\n};\r\nvar toLowerCase = function (value) { return String(value).toLowerCase(); };\r\nvar operationPredicates = {\r\n    contains: function (value, filter) { return toLowerCase(value)\r\n        .indexOf(toLowerCase(filter.value)) > -1; },\r\n    notContains: function (value, filter) { return toLowerCase(value)\r\n        .indexOf(toLowerCase(filter.value)) === -1; },\r\n    startsWith: function (value, filter) { return toLowerCase(value)\r\n        .startsWith(toLowerCase(filter.value)); },\r\n    endsWith: function (value, filter) { return toLowerCase(value)\r\n        .endsWith(toLowerCase(filter.value)); },\r\n    equal: function (value, filter) { return String(value) === String(filter.value); },\r\n    notEqual: function (value, filter) { return String(value) !== String(filter.value); },\r\n    greaterThan: function (value, filter) { return value > filter.value; },\r\n    greaterThanOrEqual: function (value, filter) { return value >= filter.value; },\r\n    lessThan: function (value, filter) { return value < filter.value; },\r\n    lessThanOrEqual: function (value, filter) { return value <= filter.value; },\r\n};\r\nvar defaultFilterPredicate = function (value, filter) {\r\n    var operation = filter.operation || 'contains';\r\n    return operationPredicates[operation](value, filter);\r\n};\r\nvar filterTree = function (tree, predicate) { return tree.reduce(function (acc, node) {\r\n    if (node[NODE_CHECK]) {\r\n        var filteredChildren = filterTree(node.children, predicate);\r\n        if (filteredChildren.length > 0) {\r\n            acc.push(__assign(__assign({}, node), { children: filteredChildren }));\r\n            return acc;\r\n        }\r\n        if (predicate(node.root, true)) {\r\n            acc.push(node.root);\r\n            return acc;\r\n        }\r\n        return acc;\r\n    }\r\n    if (predicate(node)) {\r\n        acc.push(node);\r\n        return acc;\r\n    }\r\n    return acc;\r\n}, []); };\r\nvar filterHierarchicalRows = function (rows, predicate, getRowLevelKey, getCollapsedRows) {\r\n    var tree = rowsToTree(rows, getRowLevelKey);\r\n    var collapsedRowsMeta = [];\r\n    var filteredTree = filterTree(tree, function (row, isNode) {\r\n        if (isNode) {\r\n            var collapsedRows = getCollapsedRows && getCollapsedRows(row);\r\n            if (collapsedRows && collapsedRows.length) {\r\n                var filteredCollapsedRows = collapsedRows.filter(predicate);\r\n                collapsedRowsMeta.push([row, filteredCollapsedRows]);\r\n                return !!filteredCollapsedRows.length || predicate(row);\r\n            }\r\n            if (predicate(row)) {\r\n                collapsedRowsMeta.push([row, []]);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return predicate(row);\r\n    });\r\n    return { rows: treeToRows(filteredTree), collapsedRowsMeta: new Map(collapsedRowsMeta) };\r\n};\r\nvar buildPredicate = function (initialFilterExpression, getCellValue, getColumnPredicate) {\r\n    var getSimplePredicate = function (filter) {\r\n        var columnName = filter.columnName;\r\n        var customPredicate = getColumnPredicate && getColumnPredicate(columnName);\r\n        var predicate = customPredicate || defaultFilterPredicate;\r\n        return function (row) { return predicate(getCellValue(row, columnName), filter, row); };\r\n    };\r\n    var getOperatorPredicate = function (filterExpression) {\r\n        var build = operators[toLowerCase(filterExpression.operator)];\r\n        return build && build(filterExpression.filters.map(getPredicate));\r\n    };\r\n    var getPredicate = function (filterExpression) { return (getOperatorPredicate(filterExpression)\r\n        || getSimplePredicate(filterExpression)); };\r\n    return getPredicate(initialFilterExpression);\r\n};\r\nvar filteredRows = function (rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows) {\r\n    if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {\r\n        // tslint:disable-next-line:no-object-literal-type-assertion\r\n        return { rows: rows };\r\n    }\r\n    var predicate = buildPredicate(filterExpression, getCellValue, getColumnPredicate);\r\n    return getRowLevelKey\r\n        ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows)\r\n        : { rows: rows.filter(predicate) };\r\n};\r\nvar filteredCollapsedRowsGetter = function (_a) {\r\n    var collapsedRowsMeta = _a.collapsedRowsMeta;\r\n    return function (row) { return collapsedRowsMeta && collapsedRowsMeta.get(row); };\r\n};\r\nvar unwrappedFilteredRows = function (_a) {\r\n    var rows = _a.rows;\r\n    return rows;\r\n};\n\nvar GROUP_KEY_SEPARATOR = '|';\n\nvar applyColumnGrouping = function (grouping, _a) {\r\n    var columnName = _a.columnName, groupIndex = _a.groupIndex;\r\n    var nextGrouping = grouping;\r\n    var groupingIndex = nextGrouping.findIndex(function (g) { return g.columnName === columnName; });\r\n    var targetIndex = groupIndex;\r\n    if (groupingIndex > -1) {\r\n        nextGrouping = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(grouping);\r\n        nextGrouping.splice(groupingIndex, 1);\r\n    }\r\n    else if (groupIndex === undefined) {\r\n        targetIndex = nextGrouping.length;\r\n    }\r\n    if (targetIndex > -1) {\r\n        nextGrouping = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(nextGrouping);\r\n        nextGrouping.splice(targetIndex, 0, {\r\n            columnName: columnName,\r\n        });\r\n    }\r\n    return nextGrouping;\r\n};\r\nvar changeColumnGrouping = function (_a, _b) {\r\n    var grouping = _a.grouping, expandedGroups = _a.expandedGroups;\r\n    var columnName = _b.columnName, groupIndex = _b.groupIndex;\r\n    var nextGrouping = applyColumnGrouping(grouping, { columnName: columnName, groupIndex: groupIndex });\r\n    var ungroupedColumnIndex = grouping.findIndex(function (group, index) { return !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName; });\r\n    if (ungroupedColumnIndex === -1) {\r\n        return {\r\n            grouping: nextGrouping,\r\n        };\r\n    }\r\n    var filteredExpandedGroups = expandedGroups.filter(function (group) { return group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex; });\r\n    if (filteredExpandedGroups.length === expandedGroups.length) {\r\n        return {\r\n            grouping: nextGrouping,\r\n        };\r\n    }\r\n    return {\r\n        grouping: nextGrouping,\r\n        expandedGroups: filteredExpandedGroups,\r\n    };\r\n};\r\nvar toggleExpandedGroups = function (state, _a) {\r\n    var groupKey = _a.groupKey;\r\n    var expandedGroups = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(state.expandedGroups);\r\n    var groupKeyIndex = expandedGroups.indexOf(groupKey);\r\n    if (groupKeyIndex > -1) {\r\n        expandedGroups.splice(groupKeyIndex, 1);\r\n    }\r\n    else {\r\n        expandedGroups.push(groupKey);\r\n    }\r\n    return {\r\n        expandedGroups: expandedGroups,\r\n    };\r\n};\r\nvar draftColumnGrouping = function (_a, _b) {\r\n    var grouping = _a.grouping, draftGrouping = _a.draftGrouping;\r\n    var columnName = _b.columnName, groupIndex = _b.groupIndex;\r\n    return ({\r\n        draftGrouping: applyColumnGrouping(draftGrouping || grouping, { columnName: columnName, groupIndex: groupIndex }),\r\n    });\r\n};\r\nvar cancelColumnGroupingDraft = function () { return ({\r\n    draftGrouping: null,\r\n}); };\n\nvar adjustSortIndex = function (groupingIndex, grouping, sorting) { return Math.max(grouping.slice(0, groupingIndex).reduce(function (acc, columnGrouping) {\r\n    var columnSortingIndex = sorting.findIndex(function (columnSorting) { return columnSorting.columnName === columnGrouping.columnName; });\r\n    return (columnSortingIndex === -1 ? acc - 1 : acc);\r\n}, groupingIndex), 0); };\n\nvar defaultColumnCriteria = function (value) { return ({\r\n    value: value,\r\n    key: String(value),\r\n}); };\r\nvar getGroupRows = function (rows, grouping, groupsGetter) {\r\n    if (grouping.length === 0) {\r\n        return rows;\r\n    }\r\n    var keyPrefixes = [{ prefix: '', level: 0, rows: rows }];\r\n    var resultRows = [];\r\n    var compoundKeys = {};\r\n    var _loop_1 = function () {\r\n        var _a = keyPrefixes.pop(), keyPrefix = _a.prefix, level = _a.level, currentRows = _a.rows;\r\n        var currentCompoundKey = keyPrefix.slice(0, keyPrefix.length - 1);\r\n        var groupIndex = (_a = compoundKeys[currentCompoundKey]) !== null && _a !== void 0 ? _a : -1;\r\n        var groupRows = grouping[level] && currentRows.length\r\n            ? groupsGetter(currentRows, grouping[level], keyPrefix)\r\n                .map(function (_a, rowIndex) {\r\n                var childRows = _a.childRows, params = __rest(_a, [\"childRows\"]);\r\n                var compoundKey = params.compoundKey;\r\n                compoundKeys[compoundKey] = groupIndex + rowIndex + 1;\r\n                keyPrefixes.push({\r\n                    prefix: \"\" + compoundKey + GROUP_KEY_SEPARATOR,\r\n                    level: level + 1,\r\n                    rows: childRows || [],\r\n                });\r\n                return params;\r\n            })\r\n            : currentRows;\r\n        if (groupIndex > -1) {\r\n            resultRows.splice.apply(resultRows, __spread([groupIndex + 1, 0], groupRows));\r\n        }\r\n        else {\r\n            groupRows.forEach(function (row) { return resultRows.push(row); });\r\n        }\r\n    };\r\n    while (keyPrefixes.length) {\r\n        _loop_1();\r\n    }\r\n    return resultRows;\r\n};\r\nvar getIntegratedGroups = function (rows, grouping, keyPrefix, getCellValue, getColumnCriteria) {\r\n    var columnName = grouping.columnName;\r\n    var groupCriteria = (getColumnCriteria && getColumnCriteria(columnName))\r\n        || defaultColumnCriteria;\r\n    var groups = new Map();\r\n    rows.forEach(function (row) {\r\n        var rawValue = getCellValue(row, columnName);\r\n        var _a = groupCriteria(rawValue, row), key = _a.key, value = _a.value;\r\n        var sameKeyItems = groups.get(key);\r\n        if (!sameKeyItems) {\r\n            var groupingValue = value === rawValue ? value : value || key;\r\n            groups.set(key, [groupingValue, key, [row]]);\r\n        }\r\n        else {\r\n            sameKeyItems[2].push(row);\r\n        }\r\n    });\r\n    var groupedBy = columnName;\r\n    return __spread(groups.values()).map(function (_a) {\r\n        var _b;\r\n        var _c = __read(_a, 3), value = _c[0], key = _c[1], childRows = _c[2];\r\n        return (_b = {\r\n                groupedBy: groupedBy,\r\n                compoundKey: \"\" + keyPrefix + key,\r\n                key: key,\r\n                value: value\r\n            },\r\n            _b[GRID_GROUP_CHECK] = true,\r\n            _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + \"_\" + groupedBy,\r\n            _b.childRows = childRows,\r\n            _b);\r\n    });\r\n};\n\nvar groupRowChecker = function (row) { return row[GRID_GROUP_CHECK]; };\r\nvar groupRowLevelKeyGetter = function (row) { return (row ? row[GRID_GROUP_LEVEL_KEY] : undefined); };\r\nvar groupedRows = function (rows, grouping, getCellValue, getColumnCriteria) {\r\n    var groupsGetter = function (currentRows, currentGrouping, prefix) {\r\n        return getIntegratedGroups(currentRows, currentGrouping, prefix, getCellValue, getColumnCriteria);\r\n    };\r\n    return getGroupRows(rows, grouping, groupsGetter);\r\n};\r\nvar expandedGroupRows = function (rows, grouping, expandedGroups, isExporting) {\r\n    if (!grouping.length)\r\n        return rows;\r\n    var groupingColumnNames = grouping.map(function (columnGrouping) { return columnGrouping.columnName; });\r\n    var expandedGroupsSet = new Set(expandedGroups);\r\n    var currentGroupExpanded = true;\r\n    var currentGroupLevel = 0;\r\n    return rows.reduce(function (acc, row) {\r\n        var _a;\r\n        if (!row[GRID_GROUP_CHECK]) {\r\n            if (currentGroupExpanded) {\r\n                acc.push(row);\r\n            }\r\n            else {\r\n                acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);\r\n            }\r\n            return acc;\r\n        }\r\n        var groupLevel = groupingColumnNames.indexOf(row.groupedBy);\r\n        if (groupLevel > currentGroupLevel && !currentGroupExpanded) {\r\n            return acc;\r\n        }\r\n        currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;\r\n        currentGroupLevel = groupLevel;\r\n        if (currentGroupExpanded) {\r\n            acc.push(row);\r\n        }\r\n        else {\r\n            acc.push(__assign(__assign({}, row), (_a = {}, _a[GRID_GROUP_COLLAPSED_ROWS] = [], _a)));\r\n        }\r\n        return acc;\r\n    }, []);\r\n};\r\nvar groupCollapsedRowsGetter = function (getCollapsedRows) { return function (row) { return (row[GRID_GROUP_COLLAPSED_ROWS] || (getCollapsedRows && getCollapsedRows(row))); }; };\n\nvar getCustomGroups = function (rows, grouping, keyPrefix, getChildGroups, rootRows) {\r\n    var groupedBy = grouping.columnName;\r\n    return getChildGroups(rows, grouping, rootRows)\r\n        .map(function (_a) {\r\n        var _b;\r\n        var key = _a.key, _c = _a.value, value = _c === void 0 ? key : _c, childRows = _a.childRows;\r\n        return (_b = {\r\n                groupedBy: groupedBy,\r\n                compoundKey: \"\" + keyPrefix + key,\r\n                key: key,\r\n                value: value\r\n            },\r\n            _b[GRID_GROUP_CHECK] = true,\r\n            _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + \"_\" + groupedBy,\r\n            _b.childRows = childRows,\r\n            _b);\r\n    });\r\n};\n\nvar customGroupedRows = function (rows, grouping, getChildGroups, rootRows) {\r\n    if (rootRows === void 0) { rootRows = rows; }\r\n    var groupsGetter = function (currentRows, currentGrouping, prefix) {\r\n        return getCustomGroups(currentRows, currentGrouping, prefix, getChildGroups, rootRows);\r\n    };\r\n    return getGroupRows(rows, grouping, groupsGetter);\r\n};\r\nvar customGroupingRowIdGetter = function (getRowId, rows) {\r\n    var firstRow = rows.find(function (row) { return !row[GRID_GROUP_CHECK]; });\r\n    if (!firstRow || getRowId(firstRow) !== undefined) {\r\n        return getRowId;\r\n    }\r\n    var map = new Map(rows\r\n        .filter(function (row) { return !row[GRID_GROUP_CHECK]; })\r\n        .map(function (row, rowIndex) { return [row, rowIndex]; }));\r\n    return function (row) { return map.get(row); };\r\n};\n\nvar groupingPanelItems = function (columns, grouping, draftGrouping) {\r\n    var items = draftGrouping.map(function (_a) {\r\n        var columnName = _a.columnName;\r\n        return ({\r\n            column: columns.find(function (c) { return c.name === columnName; }),\r\n            draft: !grouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }),\r\n        });\r\n    });\r\n    grouping.forEach(function (_a, index) {\r\n        var columnName = _a.columnName;\r\n        if (draftGrouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }))\r\n            return;\r\n        items.splice(index, 0, {\r\n            column: columns.find(function (c) { return c.name === columnName; }),\r\n            draft: true,\r\n        });\r\n    });\r\n    return items;\r\n};\n\nvar setCurrentPage = function (prevPage, page) { return page; };\r\nvar setPageSize = function (prevPageSize, size) { return size; };\n\nvar clamp = function (value, max) { return (Math.max(Math.min(value, max), 0)); };\n\n// tslint:disable-next-line:max-line-length\r\nvar PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';\r\nvar paginatedRows = function (rows, pageSize, page) { return (pageSize\r\n    ? rows.slice(pageSize * page, pageSize * (page + 1))\r\n    : rows); };\r\nvar rowsWithPageHeaders = function (rows, pageSize, getRowLevelKey) {\r\n    if (!pageSize || !getRowLevelKey)\r\n        return rows;\r\n    var result = rows.slice();\r\n    var headerRows = [];\r\n    var currentIndex = 0;\r\n    var _loop_1 = function () {\r\n        var row = result[currentIndex];\r\n        var levelKey = getRowLevelKey(row);\r\n        if (levelKey) {\r\n            var headerIndex = headerRows.findIndex(function (headerRow) { return getRowLevelKey(headerRow) === levelKey; });\r\n            // tslint:disable-next-line:prefer-conditional-expression\r\n            if (headerIndex === -1) {\r\n                headerRows = __spread(headerRows, [row]);\r\n            }\r\n            else {\r\n                headerRows = __spread(headerRows.slice(0, headerIndex), [row]);\r\n            }\r\n            if (headerRows.length >= pageSize) {\r\n                throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);\r\n            }\r\n        }\r\n        var indexInPage = currentIndex % pageSize;\r\n        if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {\r\n            result = __spread(result.slice(0, currentIndex), [\r\n                headerRows[indexInPage]\r\n            ], result.slice(currentIndex));\r\n        }\r\n        currentIndex += 1;\r\n    };\r\n    while (result.length > currentIndex) {\r\n        _loop_1();\r\n    }\r\n    return result;\r\n};\r\nvar rowCount = function (rows) { return rows.length; };\r\nvar pageCount = function (count, pageSize) { return (pageSize ? Math.ceil(count / pageSize) : 1); };\r\nvar currentPage = function (page, totalCount, pageSize, setCurrentPage) {\r\n    var totalPages = pageCount(totalCount, pageSize);\r\n    var adjustedCurrentPage = clamp(page, totalPages - 1);\r\n    if (page !== adjustedCurrentPage) {\r\n        setTimeout(function () { return setCurrentPage(adjustedCurrentPage); });\r\n    }\r\n    return adjustedCurrentPage;\r\n};\n\nvar firstRowOnPage = function (currentPage, pageSize, totalCount) {\r\n    if (totalCount === 0) {\r\n        return 0;\r\n    }\r\n    return pageSize ? (currentPage * pageSize) + 1 : 1;\r\n};\r\nvar lastRowOnPage = function (currentPage, pageSize, totalRowCount) {\r\n    var result = totalRowCount;\r\n    if (pageSize) {\r\n        var index = (currentPage + 1) * pageSize;\r\n        result = index > totalRowCount ? totalRowCount : index;\r\n    }\r\n    return result;\r\n};\r\nvar calculateStartPage = function (currentPage, maxButtonCount, totalPageCount) { return (Math.max(Math.min(currentPage - Math.floor(maxButtonCount / 2), (totalPageCount - maxButtonCount) + 1), 1)); };\n\nvar toggle = function (source, items, state) {\r\n    var itemsSet = new Set(items);\r\n    var sourceState = state;\r\n    if (sourceState === undefined) {\r\n        var availableSelection = source.filter(function (item) { return itemsSet.has(item); });\r\n        sourceState = availableSelection.length !== itemsSet.size;\r\n    }\r\n    if (sourceState) {\r\n        var sourceSet_1 = new Set(source);\r\n        return __spread(source, items.filter(function (item) { return !sourceSet_1.has(item); }));\r\n    }\r\n    return source.filter(function (item) { return !itemsSet.has(item); });\r\n};\n\nvar toggleSelection = function (selection, _a) {\r\n    var rowIds = _a.rowIds, state = _a.state;\r\n    return toggle(selection, rowIds, state);\r\n};\n\nvar rowsWithAvailableToSelect = function (rows, getRowId, isGroupRow) {\r\n    var dataRows = rows;\r\n    if (isGroupRow) {\r\n        dataRows = dataRows.filter(function (row) { return !isGroupRow(row); });\r\n    }\r\n    return { rows: rows, availableToSelect: dataRows.map(function (row) { return getRowId(row); }) };\r\n};\r\nvar someSelected = function (_a, selection) {\r\n    var availableToSelect = _a.availableToSelect;\r\n    var selectionSet = new Set(selection);\r\n    return availableToSelect.length !== 0 && selectionSet.size !== 0\r\n        && availableToSelect.some(function (elem) { return selectionSet.has(elem); })\r\n        && availableToSelect.some(function (elem) { return !selectionSet.has(elem); });\r\n};\r\nvar allSelected = function (_a, selection) {\r\n    var availableToSelect = _a.availableToSelect;\r\n    var selectionSet = new Set(selection);\r\n    return selectionSet.size !== 0 && availableToSelect.length !== 0\r\n        && !availableToSelect.some(function (elem) { return !selectionSet.has(elem); });\r\n};\r\nvar unwrapSelectedRows = function (_a) {\r\n    var rows = _a.rows;\r\n    return rows;\r\n};\n\nvar startEditRows = function (prevEditingRowIds, _a) {\r\n    var rowIds = _a.rowIds;\r\n    return __spread(prevEditingRowIds, rowIds);\r\n};\r\nvar stopEditRows = function (prevEditingRowIds, _a) {\r\n    var rowIds = _a.rowIds;\r\n    var rowIdSet = new Set(rowIds);\r\n    return prevEditingRowIds.filter(function (id) { return !rowIdSet.has(id); });\r\n};\r\nvar startEditCells = function (prevEditingCells, _a) {\r\n    var editingCells = _a.editingCells;\r\n    return __spread(prevEditingCells, editingCells);\r\n};\r\nvar stopEditCells = function (prevEditingCells, _a) {\r\n    var editingCells = _a.editingCells;\r\n    return prevEditingCells.filter(function (_a) {\r\n        var rowId = _a.rowId, columnName = _a.columnName;\r\n        return (!editingCells.some(function (_a) {\r\n            var currentRowId = _a.rowId, currentColumnName = _a.columnName;\r\n            return (currentRowId === rowId && currentColumnName === columnName);\r\n        }));\r\n    });\r\n};\r\nvar addRow = function (addedRows, _a) {\r\n    var _b = _a === void 0 ? { row: {} } : _a, row = _b.row;\r\n    return __spread(addedRows, [row]);\r\n};\r\nvar changeAddedRow = function (addedRows, _a) {\r\n    var rowId = _a.rowId, change = _a.change;\r\n    var result = addedRows.slice();\r\n    result[rowId] = __assign(__assign({}, result[rowId]), change);\r\n    return result;\r\n};\r\nvar cancelAddedRows = function (addedRows, _a) {\r\n    var rowIds = _a.rowIds;\r\n    var result = [];\r\n    var indexSet = new Set(rowIds);\r\n    addedRows.forEach(function (row, index) {\r\n        if (!indexSet.has(index)) {\r\n            result.push(row);\r\n        }\r\n    });\r\n    return result;\r\n};\r\nvar changeRow = function (prevRowChanges, _a) {\r\n    var _b;\r\n    var rowId = _a.rowId, change = _a.change;\r\n    var prevChange = prevRowChanges[rowId] || {};\r\n    return __assign(__assign({}, prevRowChanges), (_b = {}, _b[rowId] = __assign(__assign({}, prevChange), change), _b));\r\n};\r\nvar cancelChanges = function (prevRowChanges, _a) {\r\n    var rowIds = _a.rowIds;\r\n    var result = __assign({}, prevRowChanges);\r\n    rowIds.forEach(function (rowId) {\r\n        delete result[rowId];\r\n    });\r\n    return result;\r\n};\r\nvar deleteRows = function (deletedRowIds, _a) {\r\n    var rowIds = _a.rowIds;\r\n    return __spread(deletedRowIds, rowIds);\r\n};\r\nvar cancelDeletedRows = function (deletedRowIds, _a) {\r\n    var rowIds = _a.rowIds;\r\n    var rowIdSet = new Set(rowIds);\r\n    return deletedRowIds.filter(function (rowId) { return !rowIdSet.has(rowId); });\r\n};\n\nvar changedRowsByIds = function (changes, rowIds) {\r\n    var result = {};\r\n    rowIds.forEach(function (rowId) {\r\n        result[rowId] = changes[rowId];\r\n    });\r\n    return result;\r\n};\r\nvar addedRowsByIds = function (addedRows, rowIds) {\r\n    var rowIdSet = new Set(rowIds);\r\n    var result = [];\r\n    addedRows.forEach(function (row, index) {\r\n        if (rowIdSet.has(index)) {\r\n            result.push(row);\r\n        }\r\n    });\r\n    return result;\r\n};\r\nvar defaultCreateRowChange = function (row, value, columnName) {\r\n    var _a;\r\n    return (_a = {}, _a[columnName] = value, _a);\r\n};\r\nvar createRowChangeGetter = function (createRowChange, columnExtensions) {\r\n    if (createRowChange === void 0) { createRowChange = defaultCreateRowChange; }\r\n    if (columnExtensions === void 0) { columnExtensions = []; }\r\n    var map = columnExtensions.reduce(function (acc, columnExtension) {\r\n        if (columnExtension.createRowChange) {\r\n            acc[columnExtension.columnName] = columnExtension.createRowChange;\r\n        }\r\n        return acc;\r\n    }, {});\r\n    return function (row, value, columnName) {\r\n        if (map[columnName]) {\r\n            return map[columnName](row, value, columnName);\r\n        }\r\n        return createRowChange(row, value, columnName);\r\n    };\r\n};\n\nvar getRowChange = function (rowChanges, rowId) { return rowChanges[rowId] || {}; };\n\nvar TABLE_REORDERING_TYPE = Symbol('reordering');\n\nvar changeColumnOrder = function (order, _a) {\r\n    var sourceColumnName = _a.sourceColumnName, targetColumnName = _a.targetColumnName;\r\n    var sourceColumnIndex = order.indexOf(sourceColumnName);\r\n    var targetColumnIndex = order.indexOf(targetColumnName);\r\n    var newOrder = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(order);\r\n    newOrder.splice(sourceColumnIndex, 1);\r\n    newOrder.splice(targetColumnIndex, 0, sourceColumnName);\r\n    return newOrder;\r\n};\n\nvar TABLE_DATA_TYPE = Symbol('data');\r\nvar TABLE_NODATA_TYPE = Symbol('nodata');\r\nvar TABLE_FLEX_TYPE = Symbol('flex');\n\nvar orderedColumns = function (tableColumns, order) {\r\n    if (tableColumns === void 0) { tableColumns = []; }\r\n    return mergeSort(tableColumns, function (a, b) {\r\n        if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE)\r\n            return 0;\r\n        var aPos = order.indexOf(a.column.name);\r\n        var bPos = order.indexOf(b.column.name);\r\n        return aPos - bPos;\r\n    });\r\n};\r\nvar tableHeaderRowsWithReordering = function (tableHeaderRows) { return __spread(tableHeaderRows, [\r\n    {\r\n        key: TABLE_REORDERING_TYPE.toString(),\r\n        type: TABLE_REORDERING_TYPE,\r\n        height: 0,\r\n    },\r\n]); };\r\nvar draftOrder = function (order, sourceColumnIndex, targetColumnIndex) {\r\n    if (sourceColumnIndex === -1\r\n        || targetColumnIndex === -1\r\n        || sourceColumnIndex === targetColumnIndex) {\r\n        return order;\r\n    }\r\n    var result = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(order);\r\n    var sourceColumn = order[sourceColumnIndex];\r\n    result.splice(sourceColumnIndex, 1);\r\n    result.splice(targetColumnIndex, 0, sourceColumn);\r\n    return result;\r\n};\n\nvar getColumnWidth = function (columnWidths, name, _a) {\r\n    var columnName = _a.columnName, cachedWidths = _a.cachedWidths, shift = _a.shift, minColumnWidth = _a.minColumnWidth, maxColumnWidth = _a.maxColumnWidth, _b = _a.columnExtensions, columnExtensions = _b === void 0 ? [] : _b;\r\n    var change = name === columnName ? shift : -shift;\r\n    var column = columnWidths.find(function (elem) { return elem.columnName === name; });\r\n    var extension = columnExtensions.find(function (elem) { return elem.columnName === name; });\r\n    var width = typeof column.width === 'number'\r\n        ? column.width\r\n        : cachedWidths[name];\r\n    var minWidth = extension && extension.minWidth >= 0\r\n        ? extension.minWidth\r\n        : minColumnWidth;\r\n    var maxWidth = extension && extension.maxWidth >= 0\r\n        ? extension.maxWidth\r\n        : maxColumnWidth;\r\n    var size = Math.max(minWidth, Math.min(width + change, maxWidth));\r\n    return ({ width: width, size: size });\r\n};\r\nvar getColumnSizes = function (columnWidths, payload) {\r\n    var columnName = payload.columnName, nextColumnName = payload.nextColumnName, resizingMode = payload.resizingMode, shift = payload.shift;\r\n    var _a = getColumnWidth(columnWidths, columnName, payload), width = _a.width, size = _a.size;\r\n    if (resizingMode === 'nextColumn') {\r\n        var _b = getColumnWidth(columnWidths, nextColumnName, payload), nextWidth = _b.width, nextSize = _b.size;\r\n        if (size + nextSize !== width + nextWidth) {\r\n            var moreThanLimit = size + nextSize > width + nextWidth;\r\n            var columnExpand = shift > 0;\r\n            if (moreThanLimit !== columnExpand) {\r\n                return { size: size, nextSize: width + nextWidth - size };\r\n            }\r\n            return { size: width + nextWidth - nextSize, nextSize: nextSize };\r\n        }\r\n        return { size: size, nextSize: nextSize };\r\n    }\r\n    return { size: size };\r\n};\r\nvar isValidValue = function (value, validUnits) {\r\n    var numb = parseInt(value, 10);\r\n    var unit = numb ? value.substr(numb.toString().length) : value;\r\n    var sizeIsAuto = isNaN(numb) && unit === 'auto';\r\n    var sizeIsValid = numb >= 0 && validUnits.some(function (validUnit) { return validUnit === unit; });\r\n    return sizeIsAuto || sizeIsValid;\r\n};\r\nvar convertWidth = function (value) {\r\n    if (typeof value === 'string') {\r\n        var numb = parseInt(value, 10);\r\n        if (value.substr(numb.toString().length).length > 0) {\r\n            return value;\r\n        }\r\n        return numb;\r\n    }\r\n    return value;\r\n};\n\nvar VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\r\nvar NOT_FOR_WIDGET_UNITS = ['%'];\r\n/* tslint:disable max-line-length */\r\nvar COLUMN_RESIZING_ERROR = 'The columnWidths property of the TableColumnResizing plugin is given an invalid value.';\r\nvar specifyWidths = function (tableColumns, widths, resizingMode, onError) {\r\n    if (resizingMode !== 'widget' && resizingMode !== 'nextColumn') {\r\n        onError();\r\n    }\r\n    if (!widths.length)\r\n        return tableColumns;\r\n    return tableColumns\r\n        .reduce(function (acc, tableColumn) {\r\n        if (tableColumn.type === TABLE_DATA_TYPE) {\r\n            var columnName_1 = tableColumn.column.name;\r\n            var column = widths.find(function (el) { return el.columnName === columnName_1; });\r\n            var width = column && column.width;\r\n            if (typeof width !== 'number') {\r\n                if (width === undefined) {\r\n                    onError();\r\n                }\r\n                else if (!isValidValue(width, VALID_UNITS)) {\r\n                    onError();\r\n                }\r\n                else if (resizingMode === 'widget' && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {\r\n                    onError();\r\n                }\r\n            }\r\n            else if (width < 0) {\r\n                onError();\r\n            }\r\n            if (width === undefined) {\r\n                acc.push(tableColumn);\r\n            }\r\n            else {\r\n                acc.push(__assign(__assign({}, tableColumn), { width: convertWidth(width) }));\r\n            }\r\n        }\r\n        else {\r\n            acc.push(tableColumn);\r\n        }\r\n        return acc;\r\n    }, []);\r\n};\r\nvar tableColumnsWithWidths = function (tableColumns, columnWidths, resizingMode) { return specifyWidths(tableColumns, columnWidths, resizingMode, throwError); };\r\nvar tableColumnsWithDraftWidths = function (tableColumns, draftColumnWidths, resizingMode) { return specifyWidths(tableColumns, draftColumnWidths, resizingMode, function () { }); };\r\nvar throwError = function () {\r\n    throw new Error(COLUMN_RESIZING_ERROR);\r\n};\n\nvar changeTableColumnWidth = function (state, payload) {\r\n    var columnWidths = state.columnWidths;\r\n    var columnName = payload.columnName, nextColumnName = payload.nextColumnName, resizingMode = payload.resizingMode;\r\n    var nextColumnWidth = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(columnWidths);\r\n    var index = nextColumnWidth.findIndex(function (elem) { return elem.columnName === columnName; });\r\n    var nextIndex = nextColumnWidth.findIndex(function (elem) { return elem.columnName === nextColumnName; });\r\n    var _a = getColumnSizes(columnWidths, payload), size = _a.size, nextSize = _a.nextSize;\r\n    nextColumnWidth.splice(index, 1, { columnName: columnName, width: size });\r\n    if (resizingMode === 'nextColumn') {\r\n        nextColumnWidth.splice(nextIndex, 1, { columnName: nextColumnName, width: nextSize });\r\n    }\r\n    return {\r\n        columnWidths: nextColumnWidth,\r\n    };\r\n};\r\nvar draftTableColumnWidth = function (state, payload) {\r\n    var columnWidths = state.columnWidths;\r\n    var columnName = payload.columnName, nextColumnName = payload.nextColumnName, resizingMode = payload.resizingMode;\r\n    var _a = getColumnSizes(columnWidths, payload), size = _a.size, nextSize = _a.nextSize;\r\n    if (resizingMode === 'nextColumn') {\r\n        return { draftColumnWidths: [\r\n                { columnName: columnName, width: size }, { columnName: nextColumnName, width: nextSize },\r\n            ] };\r\n    }\r\n    return { draftColumnWidths: [{ columnName: columnName, width: size }] };\r\n};\r\nvar cancelTableColumnWidthDraft = function () { return ({\r\n    draftColumnWidths: [],\r\n}); };\n\nvar TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');\n\nvar TABLE_ADDED_TYPE = Symbol('added');\r\nvar TABLE_EDIT_TYPE = Symbol('edit');\n\nvar TABLE_HEADING_TYPE = Symbol('heading');\n\nvar isHeadingEditCommandsTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };\r\nvar isEditCommandsTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE\r\n    || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };\n\nvar tableColumnsWithEditing = function (tableColumns, width) { return __spread([\r\n    { width: convertWidth(width),\r\n        key: TABLE_EDIT_COMMAND_TYPE.toString(), type: TABLE_EDIT_COMMAND_TYPE }\r\n], tableColumns); };\n\nvar isEditTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE)\r\n    && tableColumn.type === TABLE_DATA_TYPE; };\r\nvar isAddedTableRow = function (tableRow) { return tableRow.type === TABLE_ADDED_TYPE; };\r\nvar isEditTableRow = function (tableRow) { return tableRow.type === TABLE_EDIT_TYPE; };\n\nvar tableRowsWithEditing = function (tableRows, editingRowIds, addedRows, rowHeight) {\r\n    var rowIds = new Set(editingRowIds);\r\n    var editedTableRows = tableRows\r\n        .map(function (tableRow) { return (tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId)\r\n        ? __assign(__assign({}, tableRow), { type: TABLE_EDIT_TYPE, height: rowHeight }) : tableRow); });\r\n    var addedTableRows = addedRows\r\n        .map(function (row, rowIndex) { return ({\r\n        row: row,\r\n        key: TABLE_ADDED_TYPE.toString() + \"_\" + rowIndex,\r\n        type: TABLE_ADDED_TYPE,\r\n        rowId: rowIndex,\r\n        height: rowHeight,\r\n    }); });\r\n    return __spread((0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(addedTableRows).reverse(), editedTableRows);\r\n};\n\nvar rowsWithEditingCells = function (tableBodyRows, editingCells) { return tableBodyRows.map(function (row) {\r\n    var rowId = row.rowId, type = row.type;\r\n    if (rowId !== undefined &&\r\n        type === TABLE_DATA_TYPE &&\r\n        editingCells.some(function (elem) { return elem.rowId === rowId; })) {\r\n        return __assign(__assign({}, row), { hasEditCell: true });\r\n    }\r\n    return row;\r\n}); };\r\nvar columnsWithEditingCells = function (tableColumns, editingCells) { return tableColumns.map(function (tableColumn) {\r\n    var columnName = tableColumn.column ? tableColumn.column.name : undefined;\r\n    if (columnName !== undefined && editingCells.some(function (elem) { return elem.columnName === columnName; })) {\r\n        return __assign(__assign({}, tableColumn), { hasEditCell: true });\r\n    }\r\n    return tableColumn;\r\n}); };\n\nvar TABLE_FILTER_TYPE = Symbol('filter');\r\nvar DEFAULT_FILTER_OPERATIONS = [\r\n    'contains',\r\n    'notContains',\r\n    'startsWith',\r\n    'endsWith',\r\n    'equal',\r\n    'notEqual',\r\n];\n\nvar isFilterTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE; };\r\nvar isFilterTableRow = function (tableRow) { return tableRow.type === TABLE_FILTER_TYPE; };\r\nvar getColumnFilterOperations = function (getAvailableFilterOperations, columnName) { return (getAvailableFilterOperations && getAvailableFilterOperations(columnName))\r\n    || DEFAULT_FILTER_OPERATIONS; };\r\nvar isFilterValueEmpty = function (value) { return value === undefined || !String(value).length; };\r\nvar getSelectedFilterOperation = function (filterOperations, columnName, columnFilter, columnFilterOperations) {\r\n    if (columnFilter && columnFilter.operation) {\r\n        return columnFilter.operation;\r\n    }\r\n    if (filterOperations[columnName]) {\r\n        return filterOperations[columnName];\r\n    }\r\n    return columnFilterOperations[0];\r\n};\n\nvar tableHeaderRowsWithFilter = function (headerRows, rowHeight) { return __spread(headerRows, [\r\n    { key: TABLE_FILTER_TYPE.toString(), type: TABLE_FILTER_TYPE, height: rowHeight }\r\n]); };\n\nvar TABLE_GROUP_TYPE = Symbol('group');\n\nvar TABLE_STUB_TYPE = Symbol('stub');\r\nvar getVisibleBoundaryWithFixed = function (visibleBoundary, items) { return items.reduce(function (acc, item, index) {\r\n    if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {\r\n        acc.push([index, index]);\r\n    }\r\n    return acc;\r\n}, [visibleBoundary]); };\r\nvar getVisibleBoundary = function (items, viewportStart, viewportSize, getItemSize, offset, itemSize) {\r\n    if (offset === void 0) { offset = 0; }\r\n    if (itemSize === void 0) { itemSize = 0; }\r\n    var start = null;\r\n    var end = null;\r\n    var index = 0;\r\n    var beforePosition = offset * itemSize;\r\n    var viewportEnd = viewportStart + viewportSize;\r\n    while (end === null && index < items.length) {\r\n        var item = items[index];\r\n        var afterPosition = beforePosition + getItemSize(item);\r\n        var isVisible = (beforePosition >= viewportStart && beforePosition < viewportEnd)\r\n            || (afterPosition > viewportStart && afterPosition <= viewportEnd)\r\n            || (beforePosition < viewportStart && afterPosition > viewportEnd);\r\n        if (isVisible && start === null) {\r\n            start = index;\r\n        }\r\n        if (!isVisible && start !== null) {\r\n            end = index - 1;\r\n            break;\r\n        }\r\n        index += 1;\r\n        beforePosition = afterPosition;\r\n    }\r\n    if (start !== null && end === null) {\r\n        end = index - 1;\r\n    }\r\n    start = start === null ? 0 : start;\r\n    end = end === null ? 0 : end;\r\n    return [start + offset, end + offset];\r\n};\r\nvar getRenderBoundary = function (itemsCount, visibleBoundary, overscan) {\r\n    var _a = __read(visibleBoundary, 2), start = _a[0], end = _a[1];\r\n    start = Math.max(0, start - overscan);\r\n    end = Math.min(itemsCount - 1, end + overscan);\r\n    return [start, end];\r\n};\r\nvar getColumnBoundaries = function (columns, left, width, getColumnWidth) { return (getVisibleBoundaryWithFixed(getColumnsRenderBoundary(columns.length, getVisibleBoundary(columns, left, width, getColumnWidth, 0)), columns)); };\r\nvar getRowsVisibleBoundary = function (rows, top, height, getRowHeight, offset, rowHeight, isDataRemote) {\r\n    var beforePosition = offset * rowHeight;\r\n    var noVisibleRowsLoaded = rowHeight > 0 &&\r\n        beforePosition + rows.length * rowHeight < top ||\r\n        top < beforePosition;\r\n    var boundaries;\r\n    if (isDataRemote && noVisibleRowsLoaded) {\r\n        var topIndex = Math.round(top / rowHeight);\r\n        boundaries = [topIndex, topIndex];\r\n    }\r\n    else {\r\n        boundaries = getVisibleBoundary(rows, top, height, getRowHeight, offset, rowHeight);\r\n    }\r\n    return boundaries;\r\n};\r\nvar getColumnsRenderBoundary = function (columnCount, visibleBoundary) { return getRenderBoundary(columnCount, visibleBoundary, 1); };\r\nvar getRowsRenderBoundary = function (rowsCount, visibleBoundary) { return getRenderBoundary(rowsCount, visibleBoundary, 3); };\r\nvar getSpanBoundary = function (items, visibleBoundaries, getItemSpan) { return visibleBoundaries\r\n    .map(function (visibleBoundary) {\r\n    var endIndex = Math.min(visibleBoundary[1], items.length - 1);\r\n    var end = endIndex;\r\n    var start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;\r\n    for (var index = 0; index <= endIndex; index += 1) {\r\n        var span = getItemSpan(items[index]);\r\n        if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {\r\n            start = index;\r\n        }\r\n        if (index + (span - 1) > visibleBoundary[1]) {\r\n            end = index + (span - 1);\r\n        }\r\n    }\r\n    return [start, end];\r\n}); };\r\nvar collapseBoundaries = function (itemsCount, visibleBoundaries, spanBoundaries) {\r\n    var breakpoints = new Set([0, itemsCount]);\r\n    spanBoundaries.forEach(function (rowBoundaries) { return rowBoundaries\r\n        .forEach(function (boundary) {\r\n        breakpoints.add(boundary[0]);\r\n        // next interval starts after span end point\r\n        breakpoints.add(Math.min(boundary[1] + 1, itemsCount));\r\n    }); });\r\n    visibleBoundaries\r\n        .filter(function (boundary) { return boundary.every(function (bound) { return 0 <= bound && bound < itemsCount; }); })\r\n        .forEach(function (boundary) {\r\n        for (var point = boundary[0]; point <= boundary[1]; point += 1) {\r\n            breakpoints.add(point);\r\n        }\r\n        if (boundary[1] + 1 < itemsCount) {\r\n            // close last visible point\r\n            breakpoints.add(boundary[1] + 1);\r\n        }\r\n    });\r\n    var bp = __spread(breakpoints).sort(function (a, b) { return a - b; });\r\n    var bounds = [];\r\n    for (var i = 0; i < bp.length - 1; i += 1) {\r\n        bounds.push([\r\n            bp[i],\r\n            bp[i + 1] - 1,\r\n        ]);\r\n    }\r\n    return bounds;\r\n};\r\nvar getColumnsSize = function (columns, startIndex, endIndex, getColumnSize) {\r\n    var size = 0;\r\n    for (var i = startIndex; i <= endIndex; i += 1) {\r\n        size += getColumnSize(columns[i], 0) || 0;\r\n    }\r\n    return size;\r\n};\r\nvar getCollapsedColumns = function (columns, visibleBoundaries, boundaries, getColumnWidth) {\r\n    var collapsedColumns = [];\r\n    boundaries.forEach(function (boundary) {\r\n        var isVisible = visibleBoundaries.reduce(function (acc, visibleBoundary) { return (acc || (visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1])); }, false);\r\n        if (isVisible) {\r\n            var column = columns[boundary[0]];\r\n            collapsedColumns.push(__assign(__assign({}, column), { width: getColumnWidth(column) }));\r\n        }\r\n        else {\r\n            collapsedColumns.push({\r\n                key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\r\n                type: TABLE_STUB_TYPE,\r\n                width: getColumnsSize(columns, boundary[0], boundary[1], getColumnWidth),\r\n            });\r\n        }\r\n    });\r\n    return collapsedColumns;\r\n};\r\nvar getCollapsedRows = function (rows, visibleBoundary, boundaries, getRowHeight, getCells, offset) {\r\n    var collapsedRows = [];\r\n    boundaries.forEach(function (boundary) {\r\n        var isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\r\n        if (isVisible) {\r\n            var row = rows[boundary[0] - offset];\r\n            collapsedRows.push({\r\n                row: row,\r\n                cells: getCells(row),\r\n            });\r\n        }\r\n        else {\r\n            var row = {};\r\n            collapsedRows.push({\r\n                row: {\r\n                    key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\r\n                    type: TABLE_STUB_TYPE,\r\n                    height: getColumnsSize(rows, boundary[0], boundary[1], getRowHeight),\r\n                },\r\n                cells: getCells(row),\r\n            });\r\n        }\r\n    });\r\n    return collapsedRows;\r\n};\r\nvar getCollapsedCells = function (columns, spanBoundaries, boundaries, getColSpan) {\r\n    var collapsedCells = [];\r\n    var index = 0;\r\n    var _loop_1 = function () {\r\n        var boundary = boundaries[index];\r\n        var isSpan = spanBoundaries.reduce(function (acc, spanBoundary) { return (acc || (spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1])); }, false);\r\n        if (isSpan) {\r\n            var column = columns[boundary[0]];\r\n            var realColSpan = getColSpan(column);\r\n            var realColSpanEnd_1 = (realColSpan + boundary[0]) - 1;\r\n            var colSpanEnd = boundaries.findIndex(function (colSpanBoundary) { return colSpanBoundary[0]\r\n                <= realColSpanEnd_1 && realColSpanEnd_1\r\n                <= colSpanBoundary[1]; });\r\n            collapsedCells.push({\r\n                column: column,\r\n                colSpan: (colSpanEnd - index) + 1,\r\n            });\r\n            index += 1;\r\n        }\r\n        else {\r\n            collapsedCells.push({\r\n                column: {\r\n                    key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\r\n                    type: TABLE_STUB_TYPE,\r\n                },\r\n                colSpan: 1,\r\n            });\r\n            index += 1;\r\n        }\r\n    };\r\n    while (index < boundaries.length) {\r\n        _loop_1();\r\n    }\r\n    return collapsedCells;\r\n};\r\nvar getCollapsedGrid = function (_a) {\r\n    var rows = _a.rows, columns = _a.columns, rowsVisibleBoundary = _a.rowsVisibleBoundary, columnsVisibleBoundary = _a.columnsVisibleBoundary, _b = _a.getColumnWidth, getColumnWidth = _b === void 0 ? function (column) { return column.width; } : _b, _c = _a.getRowHeight, getRowHeight = _c === void 0 ? function (row) { return row.height; } : _c, _d = _a.getColSpan, getColSpan = _d === void 0 ? function () { return 1; } : _d, totalRowCount = _a.totalRowCount, offset = _a.offset;\r\n    if (!columns.length) {\r\n        return {\r\n            columns: [],\r\n            rows: [],\r\n        };\r\n    }\r\n    var boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];\r\n    var rowSpanBoundaries = rows\r\n        .slice(boundaries[0], boundaries[1])\r\n        .map(function (row) { return getSpanBoundary(columns, columnsVisibleBoundary, function (column) { return getColSpan(row, column); }); });\r\n    var columnBoundaries = collapseBoundaries(columns.length, columnsVisibleBoundary, rowSpanBoundaries);\r\n    var rowBoundaries = collapseBoundaries(totalRowCount, [boundaries], []);\r\n    return {\r\n        columns: getCollapsedColumns(columns, columnsVisibleBoundary, columnBoundaries, getColumnWidth),\r\n        rows: getCollapsedRows(rows, boundaries, rowBoundaries, getRowHeight, function (row) { return getCollapsedCells(columns, getSpanBoundary(columns, columnsVisibleBoundary, function (column) { return getColSpan(row, column); }), columnBoundaries, function (column) { return getColSpan(row, column); }); }, offset),\r\n    };\r\n};\r\nvar getColumnWidthGetter = function (tableColumns, tableWidth, minColumnWidth) {\r\n    var colsHavingWidth = tableColumns.filter(function (col) { return typeof col.width === 'number'; });\r\n    var columnsWidth = colsHavingWidth.reduce(function (acc, col) { return (acc + col.width); }, 0);\r\n    var autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);\r\n    var autoColWidth = Math.max(autoWidth, minColumnWidth);\r\n    return function (column) { return (column.type === TABLE_FLEX_TYPE\r\n        ? null\r\n        : typeof column.width === 'number' ? column.width : autoColWidth); };\r\n};\r\nvar getCollapsedGrids = function (_a) {\r\n    var _b = _a.headerRows, headerRows = _b === void 0 ? [] : _b, _c = _a.bodyRows, bodyRows = _c === void 0 ? [] : _c, _d = _a.footerRows, footerRows = _d === void 0 ? [] : _d, columns = _a.columns, loadedRowsStart = _a.loadedRowsStart, totalRowCount = _a.totalRowCount, getCellColSpan = _a.getCellColSpan, viewport = _a.viewport, getRowHeight = _a.getRowHeight, getColumnWidth = _a.getColumnWidth;\r\n    var getColSpan = function (tableRow, tableColumn) { return getCellColSpan({ tableRow: tableRow, tableColumn: tableColumn, tableColumns: columns }); };\r\n    var getCollapsedGridBlock = function (rows, rowsVisibleBoundary, rowCount, offset) {\r\n        if (rowCount === void 0) { rowCount = rows.length; }\r\n        if (offset === void 0) { offset = 0; }\r\n        return getCollapsedGrid({\r\n            rows: rows,\r\n            columns: columns,\r\n            rowsVisibleBoundary: rowsVisibleBoundary,\r\n            columnsVisibleBoundary: viewport.columns,\r\n            getColumnWidth: getColumnWidth,\r\n            getRowHeight: getRowHeight,\r\n            getColSpan: getColSpan,\r\n            totalRowCount: rowCount,\r\n            offset: offset,\r\n        });\r\n    };\r\n    var headerGrid = getCollapsedGridBlock(headerRows, getRenderRowBounds(viewport.headerRows, headerRows.length));\r\n    var bodyGrid = getCollapsedGridBlock(bodyRows, adjustedRenderRowBounds(viewport.rows, bodyRows.length, loadedRowsStart), totalRowCount || 1, loadedRowsStart);\r\n    var footerGrid = getCollapsedGridBlock(footerRows, getRenderRowBounds(viewport.footerRows, footerRows.length));\r\n    return {\r\n        headerGrid: headerGrid,\r\n        bodyGrid: bodyGrid,\r\n        footerGrid: footerGrid,\r\n    };\r\n};\r\nvar getRenderRowBounds = function (visibleBounds, rowCount) { return getRowsRenderBoundary(rowCount, visibleBounds); };\r\nvar adjustedRenderRowBounds = function (visibleBounds, rowCount, loadedRowsStart) {\r\n    var renderRowBoundaries = getRenderRowBounds(visibleBounds, loadedRowsStart + rowCount);\r\n    var adjustedInterval = intervalUtil.intersect({ start: renderRowBoundaries[0], end: renderRowBoundaries[1] }, { start: loadedRowsStart, end: loadedRowsStart + rowCount });\r\n    return [adjustedInterval.start, adjustedInterval.end];\r\n};\n\nvar getGroupIndexByColumn = function (grouping, tableColumn) { return grouping.findIndex(function (columnGrouping) { return !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name; }); };\r\nvar isIndentCell = function (tableRow, tableColumn, grouping) {\r\n    if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name)\r\n        return false;\r\n    var rowGroupIndex = grouping.findIndex(function (columnGrouping) { return columnGrouping.columnName === tableRow.row.groupedBy; });\r\n    var columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);\r\n    return columnGroupIndex < rowGroupIndex;\r\n};\r\nvar isGroupTableCell = function (tableRow, tableColumn) { return !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE\r\n    && tableColumn.column\r\n    && tableColumn.column.name === tableRow.row.groupedBy); };\r\nvar isGroupIndentTableCell = function (tableRow, tableColumn, grouping) { return (tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE &&\r\n    isIndentCell(tableRow, tableColumn, grouping)); };\r\nvar isGroupIndentStubTableCell = function (tableRow, tableColumn, grouping) { return ((tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE &&\r\n    isIndentCell(tableRow, tableColumn, grouping))); };\r\nvar isGroupTableRow = function (tableRow) { return tableRow.type === TABLE_GROUP_TYPE; };\r\nvar isGroupRowOrdinaryCell = function (tableRow, tableColumn) { return (isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn)); };\r\nvar columnHasGroupRowSummary = function (tableColumn, groupSummaryItems) { return (!!(groupSummaryItems && groupSummaryItems\r\n    .some(function (item) { return ((!item.showInGroupFooter && item.alignByColumn)\r\n    && item.columnName === (tableColumn.column && tableColumn.column.name)); }))); };\r\nvar isRowSummaryCell = function (tableRow, tableColumn, grouping, groupSummaryItems) { return (columnHasGroupRowSummary(tableColumn, groupSummaryItems)\r\n    && !isGroupIndentTableCell(tableRow, tableColumn, grouping)); };\r\nvar isPreviousCellContainSummary = function (tableRow, tableColumn, tableColumns, grouping, groupSummaryItems) {\r\n    var columnIndex = tableColumns.indexOf(tableColumn);\r\n    return columnIndex > 0 && isRowSummaryCell(tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems);\r\n};\r\nvar calculateGroupCellIndent = function (tableColumn, grouping, indentWidth) { return (indentWidth * getGroupIndexByColumn(grouping, tableColumn)); };\r\nvar sortAndSpliceColumns = function (tableColumns, firstVisibleColumnIndex) {\r\n    var groupColumns = tableColumns.filter(function (col) { return col.type === TABLE_GROUP_TYPE; });\r\n    var dataColumns = tableColumns.filter(function (col) { return col.type === TABLE_DATA_TYPE; });\r\n    var flexColumns = tableColumns.filter(function (col) { return col.type === TABLE_FLEX_TYPE; });\r\n    var otherColumns = tableColumns.filter(function (col) {\r\n        return col.type !== TABLE_DATA_TYPE &&\r\n            col.type !== TABLE_GROUP_TYPE &&\r\n            col.type !== TABLE_FLEX_TYPE;\r\n    });\r\n    if (firstVisibleColumnIndex) {\r\n        var firstGroupIndex = tableColumns.indexOf(groupColumns[0]);\r\n        otherColumns.splice(0, Math.min(firstVisibleColumnIndex, firstGroupIndex));\r\n    }\r\n    return __spread(groupColumns, otherColumns, dataColumns, flexColumns);\r\n};\n\nvar tableColumnsWithDraftGrouping = function (tableColumns, grouping, draftGrouping, showColumnWhenGrouped) { return tableColumns\r\n    .reduce(function (acc, tableColumn) {\r\n    if (tableColumn.type !== TABLE_DATA_TYPE) {\r\n        acc.push(tableColumn);\r\n        return acc;\r\n    }\r\n    var columnName = tableColumn.column && tableColumn.column.name || '';\r\n    var columnGroupingExists = grouping\r\n        .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });\r\n    var columnDraftGroupingExists = draftGrouping\r\n        .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });\r\n    if ((!columnGroupingExists && !columnDraftGroupingExists)\r\n        || showColumnWhenGrouped(columnName)) {\r\n        acc.push(tableColumn);\r\n    }\r\n    else if ((!columnGroupingExists && columnDraftGroupingExists)\r\n        || (columnGroupingExists && !columnDraftGroupingExists)) {\r\n        acc.push(__assign(__assign({}, tableColumn), { draft: true }));\r\n    }\r\n    return acc;\r\n    // tslint:disable-next-line: prefer-array-literal\r\n}, []); };\r\nvar tableColumnsWithGrouping = function (columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped) { return __spread(grouping.map(function (columnGrouping) {\r\n    var groupedColumn = columns.find(function (column) { return column.name === columnGrouping.columnName; });\r\n    return {\r\n        key: TABLE_GROUP_TYPE.toString() + \"_\" + groupedColumn.name,\r\n        type: TABLE_GROUP_TYPE,\r\n        column: groupedColumn,\r\n        width: indentColumnWidth,\r\n    };\r\n}), tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped)); };\r\nvar tableRowsWithGrouping = function (tableRows, isGroupRow) { return tableRows.map(function (tableRow) {\r\n    if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {\r\n        return tableRow;\r\n    }\r\n    return __assign(__assign({}, tableRow), { key: TABLE_GROUP_TYPE.toString() + \"_\" + tableRow.row.compoundKey, type: TABLE_GROUP_TYPE });\r\n}); };\r\nvar isRowLevelSummary = function (groupSummaryItems, colName) { return (groupSummaryItems.some(function (item) { return (!item.showInGroupFooter && item.alignByColumn && item.columnName === colName); })); };\r\nvar groupSummaryChains = function (tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex) {\r\n    var captionStarted = false;\r\n    return sortAndSpliceColumns(tableColumns, firstVisibleColumnIndex)\r\n        .reduce(function (acc, col) {\r\n        var colName = (col.column && col.column.name);\r\n        var isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE\r\n            && tableRow.row.groupedBy === colName;\r\n        var isIndentColumn = col.type === TABLE_GROUP_TYPE\r\n            && tableRow.row.groupedBy !== colName && !captionStarted;\r\n        if (isStartOfGroupCaption) {\r\n            captionStarted = true;\r\n        }\r\n        if (isStartOfGroupCaption || isIndentColumn) {\r\n            acc.push([colName]);\r\n        }\r\n        else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {\r\n            acc.push([colName]);\r\n            acc.push([]);\r\n        }\r\n        else {\r\n            acc[acc.length - 1].push(colName);\r\n        }\r\n        return acc;\r\n    }, [[]]);\r\n};\r\nvar tableGroupCellColSpanGetter = function (getTableCellColSpan, groupSummaryItems, firstVisibleColumnIndex) { return function (params) {\r\n    var _a;\r\n    var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;\r\n    if (tableRow.type === TABLE_GROUP_TYPE) {\r\n        var colName_1 = (_a = tableColumn.column) === null || _a === void 0 ? void 0 : _a.name;\r\n        var dataColumnGroupedBy_1 = tableRow.row.groupedBy === colName_1 && tableColumn.type !== TABLE_GROUP_TYPE;\r\n        var chains = groupSummaryChains(tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex);\r\n        var chain = chains.find(function (ch) { return !dataColumnGroupedBy_1 && ch[0] === colName_1; });\r\n        if (chain) {\r\n            return chain.length;\r\n        }\r\n    }\r\n    return getTableCellColSpan(params);\r\n}; };\n\nvar isHeadingTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE; };\r\nvar isHeadingTableRow = function (tableRow) { return (tableRow.type === TABLE_HEADING_TYPE); };\r\nvar findChainByColumnIndex = function (chains, columnIndex) { return (chains.find(function (chain) { return (chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length); })); };\r\nvar splitHeaderColumnChains = function (tableColumnChains, tableColumns, shouldSplitChain, extendChainProps) { return (tableColumnChains.map(function (row, rowIndex) { return row\r\n    .reduce(function (acc, chain) {\r\n    var currentChain = null;\r\n    chain.columns.forEach(function (col) {\r\n        var column = tableColumns.find(function (c) { return c.key === col.key; });\r\n        var isNewGroup = shouldSplitChain(currentChain, column, rowIndex);\r\n        if (isNewGroup) {\r\n            var start = currentChain\r\n                ? (currentChain.start + currentChain.columns.length)\r\n                : chain.start;\r\n            acc.push(__assign(__assign(__assign({}, chain), extendChainProps(column)), { start: start, columns: [] }));\r\n            currentChain = acc[acc.length - 1];\r\n        }\r\n        currentChain.columns.push(column);\r\n    });\r\n    return acc;\r\n}, []); })); };\r\nvar generateSimpleChains = function (rows, columns) { return (rows.map(function () { return ([{\r\n        columns: columns,\r\n        start: 0,\r\n    }]); })); };\r\nvar nextColumnName = function (tableColumns, index) {\r\n    var isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;\r\n    return isNextColumnHasName\r\n        ? tableColumns[index + 1].column.name\r\n        : undefined;\r\n};\r\nvar getNextColumnName = function (tableColumns, columnName) {\r\n    var index = tableColumns.findIndex(function (elem) {\r\n        return elem.column && elem.column.name === columnName;\r\n    });\r\n    return index >= 0\r\n        ? nextColumnName(tableColumns, index)\r\n        : undefined;\r\n};\n\nvar tableRowsWithHeading = function (headerRows) { return __spread([\r\n    { key: TABLE_HEADING_TYPE.toString(), type: TABLE_HEADING_TYPE }\r\n], headerRows); };\n\nvar TABLE_BAND_TYPE = Symbol('band');\r\nvar BAND_GROUP_CELL = 'bandGroupCell';\r\nvar BAND_HEADER_CELL = 'bandHeaderCell';\r\nvar BAND_EMPTY_CELL = 'bandEmptyCell';\r\nvar BAND_DUPLICATE_RENDER = 'bandDuplicateRender';\r\nvar BAND_FILL_LEVEL_CELL = 'bandFillLevelCell';\n\nvar isBandedTableRow = function (tableRow) { return (tableRow.type === TABLE_BAND_TYPE); };\r\nvar isBandedOrHeaderRow = function (tableRow) { return isBandedTableRow(tableRow)\r\n    || tableRow.type === TABLE_HEADING_TYPE; };\r\nvar isNoDataColumn = function (columnType) { return columnType !== TABLE_DATA_TYPE; };\r\nvar getColumnMeta = function (columnName, bands, tableRowLevel, key, level, title, result) {\r\n    if (key === void 0) { key = ''; }\r\n    if (level === void 0) { level = 0; }\r\n    if (title === void 0) { title = null; }\r\n    if (result === void 0) { result = null; }\r\n    return bands.reduce(function (acc, band) {\r\n        if (band.columnName === columnName) {\r\n            return __assign(__assign({}, acc), { title: title, level: level, key: key });\r\n        }\r\n        if (band.children !== undefined) {\r\n            var rowLevelPassed = level > tableRowLevel;\r\n            var bandTitle = rowLevelPassed ? title : band.title;\r\n            var bandKey = rowLevelPassed ? key : key + \"_\" + bandTitle;\r\n            return getColumnMeta(columnName, band.children, tableRowLevel, bandKey, level + 1, bandTitle, acc);\r\n        }\r\n        return acc;\r\n    }, result || { level: level, title: title, key: title });\r\n};\r\nvar calculateBand = function (visibleBound, headerChain) {\r\n    if (visibleBound) {\r\n        var bandStart = Math.max(visibleBound[0], headerChain.start);\r\n        var bandEnd = Math.min(visibleBound[1] + 1, headerChain.start + headerChain.columns.length);\r\n        return [bandStart, bandEnd];\r\n    }\r\n    return [headerChain.start, headerChain.start + headerChain.columns.length];\r\n};\r\nvar getBandComponent = function (_a, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains, columnVisibleIntervals, bandLevelsVisibility) {\r\n    var currentTableColumn = _a.tableColumn, tableRow = _a.tableRow, rowSpan = _a.rowSpan;\r\n    if (rowSpan)\r\n        return { type: BAND_DUPLICATE_RENDER, payload: null };\r\n    var maxLevel = tableHeaderRows.filter(function (column) { return column.type === TABLE_BAND_TYPE; }).length + 1;\r\n    var level = tableRow.level;\r\n    var currentRowLevel = level === undefined\r\n        ? maxLevel - 1 : level;\r\n    var currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE\r\n        ? getColumnMeta(currentTableColumn.column.name, columnBands, currentRowLevel)\r\n        : { level: 0, title: '' };\r\n    var currentColumnIndex = tableColumns\r\n        .findIndex(function (column) { return column.key === currentTableColumn.key; });\r\n    var levelsCount = bandLevelsVisibility.length;\r\n    var visibleLevelsCount = bandLevelsVisibility.filter(Boolean).length;\r\n    if (currentColumnMeta.level < currentRowLevel) {\r\n        var shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount\r\n            && !bandLevelsVisibility[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;\r\n        if (shouldFillLevel) {\r\n            return { type: BAND_FILL_LEVEL_CELL, payload: null };\r\n        }\r\n        return { type: BAND_EMPTY_CELL, payload: null };\r\n    }\r\n    var previousTableColumn = tableColumns[currentColumnIndex - 1];\r\n    var beforeBorder = false;\r\n    if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE\r\n        && isNoDataColumn(previousTableColumn.type)) {\r\n        beforeBorder = true;\r\n    }\r\n    var isStubColumn = currentTableColumn.type === TABLE_STUB_TYPE;\r\n    var isColumnVisible = currentColumnIndex >= 0;\r\n    if (currentColumnMeta.level === currentRowLevel) {\r\n        if (isStubColumn) {\r\n            var cellRowSpan = visibleLevelsCount < levelsCount\r\n                ? visibleLevelsCount || 1\r\n                : maxLevel;\r\n            return {\r\n                type: BAND_FILL_LEVEL_CELL,\r\n                payload: {\r\n                    rowSpan: cellRowSpan,\r\n                },\r\n            };\r\n        }\r\n        if (isColumnVisible) {\r\n            return {\r\n                type: BAND_HEADER_CELL,\r\n                payload: __assign({ tableRow: tableHeaderRows.find(function (row) { return row.type === TABLE_HEADING_TYPE; }), rowSpan: maxLevel - currentRowLevel }, beforeBorder && { beforeBorder: beforeBorder }),\r\n            };\r\n        }\r\n    }\r\n    if (!isColumnVisible)\r\n        return { type: BAND_EMPTY_CELL, payload: null };\r\n    var currentColumnChain = findChainByColumnIndex(tableHeaderColumnChains[currentRowLevel], currentColumnIndex);\r\n    var columnVisibleBoundary = columnVisibleIntervals.find(function (_a) {\r\n        var _b = __read(_a, 2), start = _b[0], end = _b[1];\r\n        return (start <= currentColumnIndex && currentColumnIndex <= end);\r\n    });\r\n    var _b = __read(calculateBand(columnVisibleBoundary, currentColumnChain), 2), bandStart = _b[0], bandEnd = _b[1];\r\n    if (bandStart < currentColumnIndex) {\r\n        return { type: null, payload: null };\r\n    }\r\n    return {\r\n        type: BAND_GROUP_CELL,\r\n        payload: __assign({ colSpan: bandEnd - bandStart, value: currentColumnMeta.title, column: currentColumnMeta }, beforeBorder && { beforeBorder: beforeBorder }),\r\n    };\r\n};\n\nvar emptyVirtualRows = {\r\n    skip: Number.POSITIVE_INFINITY,\r\n    rows: [],\r\n};\r\nvar pluckSubarray = function (source, sourceStart, left, right) { return (source.slice(left - sourceStart, right - sourceStart)); };\r\nvar mergeRows = function (rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart) {\r\n    var breakpoints = [\r\n        rowsInterval.start, rowsInterval.end,\r\n        cacheInterval.start, cacheInterval.end,\r\n    ]\r\n        .filter(function (i) { return 0 <= i && i < Number.POSITIVE_INFINITY; })\r\n        .sort(function (a, b) { return a - b; });\r\n    var result = [];\r\n    if (breakpoints.length > 1) {\r\n        for (var i = 0; i < breakpoints.length - 1; i += 1) {\r\n            var left = breakpoints[i];\r\n            var right = breakpoints[i + 1];\r\n            var chunk = rowsInterval.start <= left && right <= rowsInterval.end\r\n                ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority\r\n                : pluckSubarray(cacheRows, cacheStart, left, right);\r\n            result = result.concat(chunk);\r\n        }\r\n    }\r\n    return {\r\n        skip: breakpoints[0],\r\n        rows: result,\r\n    };\r\n};\r\nvar correctRequestedRange = function (calculatedRange, referenceIndex, pageSize) {\r\n    var start = calculatedRange.start, end = calculatedRange.end;\r\n    if (start - referenceIndex > pageSize / 2) {\r\n        return { start: start - pageSize, end: start };\r\n    }\r\n    return { start: start, end: end };\r\n};\r\nvar calculateRequestedRange = function (virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll) {\r\n    var loadedInterval = intervalUtil.getRowsInterval(virtualRows);\r\n    var isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;\r\n    if (isAdjacentPage) {\r\n        var calculatedRange = intervalUtil.difference(newRange, loadedInterval);\r\n        if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {\r\n            return correctRequestedRange(calculatedRange, referenceIndex, pageSize);\r\n        }\r\n        return calculatedRange;\r\n    }\r\n    // load 3 pages at once because a missing page will be loaded anyway\r\n    return newRange;\r\n};\r\nvar rowToPageIndex = function (rowIndex, pageSize) { return Math.floor(rowIndex / pageSize); };\r\nvar recalculateBounds = function (middleIndex, pageSize, totalCount) {\r\n    var currentPageIndex = rowToPageIndex(middleIndex, pageSize);\r\n    var prevPageIndex = currentPageIndex - 1;\r\n    var nextPageIndex = currentPageIndex + 2;\r\n    var start = Math.max(0, prevPageIndex * pageSize);\r\n    var end = Math.min(nextPageIndex * pageSize, totalCount);\r\n    return {\r\n        start: start,\r\n        end: end,\r\n    };\r\n};\r\nvar trimRowsToInterval = function (virtualRows, targetInterval) {\r\n    var rowsInterval = intervalUtil.getRowsInterval(virtualRows);\r\n    var intersection = intervalUtil.intersect(rowsInterval, targetInterval);\r\n    if (intervalUtil.empty === intersection) {\r\n        return emptyVirtualRows;\r\n    }\r\n    var rows = pluckSubarray(virtualRows.rows, virtualRows.skip, intersection.start, intersection.end);\r\n    return {\r\n        rows: rows,\r\n        skip: intersection.start,\r\n    };\r\n};\r\nvar getAvailableRowCount = function (isInfiniteScroll, newRowCount, lastRowCount, totalRowCount) {\r\n    return (isInfiniteScroll\r\n        ? Math.min(Math.max(newRowCount, lastRowCount), totalRowCount)\r\n        : totalRowCount);\r\n};\r\nvar getForceReloadInterval = function (virtualRows, pageSize, totalRowCount) {\r\n    var _a = intervalUtil.getRowsInterval(virtualRows), start = _a.start, intervalEnd = _a.end;\r\n    var end = Math.min(Math.max(start + pageSize * 2, intervalEnd), Math.max(start + pageSize * 2, totalRowCount));\r\n    return {\r\n        start: start,\r\n        end: end,\r\n    };\r\n};\r\nvar getRequestMeta = function (referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll) {\r\n    var actualBounds = forceReload\r\n        ? getForceReloadInterval(virtualRows, pageSize, totalRowCount)\r\n        : recalculateBounds(referenceIndex, pageSize, totalRowCount);\r\n    var requestedRange = forceReload\r\n        ? actualBounds\r\n        : calculateRequestedRange(virtualRows, actualBounds, pageSize, referenceIndex, isInfiniteScroll);\r\n    return { requestedRange: requestedRange, actualBounds: actualBounds };\r\n};\r\nvar needFetchMorePages = function (virtualRows, referenceIndex, pageSize) {\r\n    var _a = intervalUtil.getRowsInterval(virtualRows), start = _a.start, end = _a.end;\r\n    var loadCount = end - start;\r\n    var topTriggerIndex = start > 0 ? start + pageSize : 0;\r\n    var bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize * 1.5);\r\n    if (loadCount <= 0) {\r\n        return false;\r\n    }\r\n    return (referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex);\r\n};\r\nvar getReferenceIndex = function (_a) {\r\n    var _b = __read(_a.rows, 2), top = _b[0], bottom = _b[1];\r\n    return ((top + bottom) / 2);\r\n};\r\nvar shouldSendRequest = function (_a, requestedPageIndex) {\r\n    var start = _a.start, end = _a.end;\r\n    var newPageIndex = start;\r\n    var loadCount = (end - start);\r\n    return newPageIndex !== requestedPageIndex && loadCount > 0;\r\n};\n\nvar empty = {\r\n    start: Number.POSITIVE_INFINITY,\r\n    end: Number.NEGATIVE_INFINITY,\r\n};\r\nvar getRowsInterval = function (r) { return (r === emptyVirtualRows\r\n    ? empty\r\n    : {\r\n        start: r.skip,\r\n        end: r.skip + r.rows.length,\r\n    }); };\r\nvar getLength = function (a) { return a.end - a.start; };\r\nvar intersect = function (a, b) {\r\n    if (a.end < b.start || b.end < a.start) {\r\n        return empty;\r\n    }\r\n    return {\r\n        start: Math.max(a.start, b.start),\r\n        end: Math.min(a.end, b.end),\r\n    };\r\n};\r\nvar difference = function (a, b) {\r\n    if (empty === intervalUtil.intersect(a, b)) {\r\n        return a;\r\n    }\r\n    if (b.end < a.end) {\r\n        return {\r\n            start: b.end,\r\n            end: a.end,\r\n        };\r\n    }\r\n    if (a.start < b.start) {\r\n        return {\r\n            start: a.start,\r\n            end: b.start,\r\n        };\r\n    }\r\n    return empty;\r\n};\r\nvar intervalUtil = {\r\n    empty: empty,\r\n    getRowsInterval: getRowsInterval,\r\n    getLength: getLength,\r\n    intersect: intersect,\r\n    difference: difference,\r\n};\n\nvar tableRowsWithBands = function (tableHeaderRows, columnBands, tableColumns) {\r\n    var tableDataColumns = tableColumns.filter(function (column) { return column.type === TABLE_DATA_TYPE; });\r\n    var getMaxNestedLevel = function (bands, level, result) {\r\n        if (level === void 0) { level = 0; }\r\n        if (result === void 0) { result = null; }\r\n        return (bands.reduce(function (acc, column) {\r\n            if (column.children !== undefined) {\r\n                return getMaxNestedLevel(column.children, level + 1, acc);\r\n            }\r\n            var isDataColumn = tableDataColumns.findIndex(function (dataColumn) { return !!dataColumn.column && dataColumn.column.name === column.columnName; }) > -1;\r\n            if (level > acc.level && isDataColumn) {\r\n                return __assign(__assign({}, acc), { level: level });\r\n            }\r\n            return acc;\r\n        }, result || { level: 0 }));\r\n    };\r\n    var tableBandHeaders = Array.from({\r\n        length: getMaxNestedLevel(columnBands, 0).level,\r\n    })\r\n        .map(function (row, index) { return ({\r\n        key: TABLE_BAND_TYPE.toString() + \"_\" + index,\r\n        type: TABLE_BAND_TYPE,\r\n        level: index,\r\n    }); });\r\n    return __spread(tableBandHeaders, tableHeaderRows);\r\n};\r\nvar tableHeaderColumnChainsWithBands = function (tableHeaderRows, tableColumns, bands) {\r\n    var chains = generateSimpleChains(tableHeaderRows, tableColumns);\r\n    var maxBandRowIndex = tableHeaderRows\r\n        .filter(function (row) { return row.type === TABLE_BAND_TYPE; })\r\n        .length;\r\n    var rawBandChains = chains.slice(0, maxBandRowIndex);\r\n    var currentBand = null;\r\n    var shouldSplitChain = function (chain, column, rowIndex) {\r\n        if (rowIndex > maxBandRowIndex)\r\n            return false;\r\n        var columnName = column.column && column.column.name || '';\r\n        currentBand = getColumnMeta(columnName, bands, rowIndex);\r\n        return !chain\r\n            || chain.key !== currentBand.key;\r\n    };\r\n    var extendChainProps = function () { return ({\r\n        bandTitle: currentBand === null || currentBand === void 0 ? void 0 : currentBand.title,\r\n        key: currentBand === null || currentBand === void 0 ? void 0 : currentBand.key,\r\n    }); };\r\n    var bandChains = splitHeaderColumnChains(rawBandChains, tableColumns, shouldSplitChain, extendChainProps);\r\n    return __spread(bandChains, chains.slice(maxBandRowIndex));\r\n};\r\nvar getBandLevels = function (columnsBands, levels, level) {\r\n    if (levels === void 0) { levels = {}; }\r\n    if (level === void 0) { level = 0; }\r\n    columnsBands.forEach(function (band) {\r\n        if (band.title) {\r\n            levels[band.title] = level;\r\n        }\r\n        if (band.children) {\r\n            getBandLevels(band.children, levels, level + 1);\r\n        }\r\n    });\r\n    return levels;\r\n};\r\nvar columnBandLevels = function (columnsBands) { return (getBandLevels(columnsBands)); };\r\nvar bandLevelsVisibility = function (columnIntervals, tableHeaderColumnChains, bandLevels) {\r\n    var rowsWithBands = tableHeaderColumnChains\r\n        .filter(function (r) { return r.filter(function (ch) { return !!ch.bandTitle; }).length; });\r\n    var visibleIntervals = columnIntervals.map(function (_a) {\r\n        var _b = __read(_a, 2), start = _b[0], end = _b[1];\r\n        return ({ start: start, end: end });\r\n    });\r\n    var isBandChainVisible = function (chain) { return (visibleIntervals.some(function (interval) { return (intervalUtil.intersect(interval, { start: chain.start, end: chain.start + chain.columns.length - 1 }) !== intervalUtil.empty); })); };\r\n    var getVisibleBandsByLevel = function (level) { return (\r\n    // Note: a visible band level always matches with it's row\r\n    rowsWithBands[level]\r\n        ? rowsWithBands[level].filter(function (chain) { return (bandLevels[chain.bandTitle] === level && isBandChainVisible(chain)); })\r\n        : []); };\r\n    return rowsWithBands.reduce(function (acc, _, index) {\r\n        var rowBands = getVisibleBandsByLevel(index);\r\n        return __spread(acc, [!!rowBands.length]);\r\n    }, []);\r\n};\r\nvar columnVisibleIntervals = function (viewport, tableColumns) { return (viewport ? viewport.columns : [[0, tableColumns.length]]); };\n\nvar toggleDetailRowExpanded = function (prevExpanded, _a) {\r\n    var rowId = _a.rowId, state = _a.state;\r\n    return toggle(prevExpanded, [rowId], state);\r\n};\n\nvar TABLE_DETAIL_TYPE = Symbol('detail');\n\nvar isDetailRowExpanded = function (expandedDetailRowIds, rowId) { return expandedDetailRowIds.indexOf(rowId) > -1; };\r\nvar isDetailToggleTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE; };\r\nvar isDetailTableRow = function (tableRow) { return tableRow.type === TABLE_DETAIL_TYPE; };\r\nvar isDetailTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };\n\nvar tableRowsWithExpandedDetail = function (tableRows, expandedDetailRowIds, rowHeight) {\r\n    var result = tableRows;\r\n    expandedDetailRowIds\r\n        .forEach(function (expandedRowId) {\r\n        var rowIndex = result.findIndex(function (tableRow) { return tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId; });\r\n        if (rowIndex === -1)\r\n            return;\r\n        var insertIndex = rowIndex + 1;\r\n        var _a = result[rowIndex], row = _a.row, rowId = _a.rowId;\r\n        result = __spread(result.slice(0, insertIndex), [\r\n            {\r\n                rowId: rowId,\r\n                row: row,\r\n                key: TABLE_DETAIL_TYPE.toString() + \"_\" + rowId,\r\n                type: TABLE_DETAIL_TYPE,\r\n                height: rowHeight,\r\n            }\r\n        ], result.slice(insertIndex));\r\n    });\r\n    return result;\r\n};\r\nvar tableColumnsWithDetail = function (tableColumns, toggleColumnWidth) { return __spread([\r\n    { key: TABLE_DETAIL_TYPE.toString(), type: TABLE_DETAIL_TYPE, width: toggleColumnWidth }\r\n], tableColumns); };\r\nvar tableDetailCellColSpanGetter = function (getTableCellColSpan) { return function (params) {\r\n    var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;\r\n    if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {\r\n        return tableColumns.length;\r\n    }\r\n    return getTableCellColSpan(params);\r\n}; };\n\nvar TABLE_SELECT_TYPE = Symbol('select');\n\nvar isSelectTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE; };\r\nvar isSelectAllTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE; };\r\nvar isRowHighlighted = function (highlightRow, selection, tableRow) { return (highlightRow && selection && selection.includes(tableRow.rowId)); };\n\nvar tableColumnsWithSelection = function (tableColumns, selectionColumnWidth) { return __spread([\r\n    { key: TABLE_SELECT_TYPE.toString(), type: TABLE_SELECT_TYPE, width: selectionColumnWidth }\r\n], tableColumns); };\n\nvar VALID_UNITS$1 = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\r\nvar TABLE_ERROR = 'The columnExtension property of the Table plugin is given an invalid value.';\r\nvar isDataTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE; };\r\nvar isHeaderStubTableCell = function (tableRow, headerRows) { return headerRows.indexOf(tableRow) > -1; };\r\nvar isDataTableRow = function (tableRow) { return tableRow.type === TABLE_DATA_TYPE; };\r\nvar isNoDataTableRow = function (tableRow) { return tableRow.type === TABLE_NODATA_TYPE; };\r\nvar isNoDataTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };\r\nvar isStubTableCell = function (tableRow) { return (tableRow.type === TABLE_STUB_TYPE); };\r\nvar checkTableColumnExtensions = function (columnExtensions) {\r\n    if (columnExtensions) {\r\n        columnExtensions.map(function (column) {\r\n            var width = column.width;\r\n            if (typeof width === 'string') {\r\n                if (!isValidValue(width, VALID_UNITS$1)) {\r\n                    throw new Error(TABLE_ERROR);\r\n                }\r\n            }\r\n        });\r\n    }\r\n};\n\nvar getColumnExtension = function (columnExtensions, columnName) {\r\n    if (!columnExtensions) {\r\n        // tslint:disable-next-line:no-object-literal-type-assertion\r\n        return {};\r\n    }\r\n    var columnExtension = columnExtensions.find(function (extension) { return extension.columnName === columnName; });\r\n    if (!columnExtension) {\r\n        // tslint:disable-next-line:no-object-literal-type-assertion\r\n        return {};\r\n    }\r\n    return columnExtension;\r\n};\r\nvar getColumnExtensionValueGetter = function (columnExtensions, extensionName, defaultValue) { return function (columnName) {\r\n    if (columnExtensions) {\r\n        var columnExtension = getColumnExtension(columnExtensions, columnName);\r\n        var extensionValue = columnExtension[extensionName];\r\n        return extensionValue !== undefined ? extensionValue : defaultValue;\r\n    }\r\n    return defaultValue;\r\n}; };\n\nvar tableColumnsWithDataRows = function (columns, columnExtensions) { return columns.map(function (column) {\r\n    var name = column.name;\r\n    var columnExtension = getColumnExtension(columnExtensions, name);\r\n    var width = convertWidth(columnExtension.width);\r\n    return {\r\n        column: column,\r\n        key: TABLE_DATA_TYPE.toString() + \"_\" + name,\r\n        type: TABLE_DATA_TYPE,\r\n        width: width,\r\n        align: columnExtension.align,\r\n        wordWrapEnabled: columnExtension.wordWrapEnabled,\r\n    };\r\n}); };\r\nvar tableRowsWithDataRows = function (rows, getRowId, isRemoteRowsLoading) { return (!rows.length && !isRemoteRowsLoading\r\n    ? [{ key: TABLE_NODATA_TYPE.toString(), type: TABLE_NODATA_TYPE }]\r\n    : rows.map(function (row, dataIndex) {\r\n        var rowId = getRowId(row);\r\n        return {\r\n            row: row,\r\n            // dataIndex,\r\n            rowId: rowId,\r\n            type: TABLE_DATA_TYPE,\r\n            key: TABLE_DATA_TYPE.toString() + \"_\" + rowId,\r\n        };\r\n    })); };\r\nvar tableCellColSpanGetter = function (params) {\r\n    var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;\r\n    if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {\r\n        return tableColumns.length;\r\n    }\r\n    return 1;\r\n};\n\nvar visibleTableColumns = function (tableColumns, hiddenColumnNames) {\r\n    if (tableColumns === void 0) { tableColumns = []; }\r\n    return tableColumns.filter(function (tableColumn) { return tableColumn.type !== TABLE_DATA_TYPE\r\n        || hiddenColumnNames.indexOf(tableColumn.column.name) === -1; });\r\n};\n\nvar tableDataColumnsExist = function (tableColumns) { return tableColumns.some(function (column) { return column.type === TABLE_DATA_TYPE; }); };\n\nvar columnChooserItems = function (columns, hiddenColumnNames) { return columns.map(function (column) { return ({\r\n    column: column,\r\n    hidden: hiddenColumnNames.indexOf(column.name) !== -1,\r\n}); }); };\n\nvar toggleColumn = function (hiddenColumnNames, columnName) { return (hiddenColumnNames.indexOf(columnName) === -1\r\n    ? __spread(hiddenColumnNames, [columnName]) : hiddenColumnNames.filter(function (hiddenColumn) { return hiddenColumn !== columnName; })); };\n\nvar toggleRowExpanded = function (prevExpanded, _a) {\r\n    var rowId = _a.rowId, state = _a.state;\r\n    return toggle(prevExpanded, [rowId], state);\r\n};\n\nvar GRID_TREE_NODE_TYPE = Symbol('treeNode');\n\nvar customTreeRowsWithMeta = function (rows, getChildRows) {\r\n    var rowsToProcess = [{ row: null, level: -1 }];\r\n    var treeRows = [];\r\n    var _loop_1 = function () {\r\n        var _a = rowsToProcess.shift(), currentRow = _a.row, level = _a.level;\r\n        var rowIndex = treeRows.findIndex(function (_a) {\r\n            var row = _a.row;\r\n            return row === currentRow;\r\n        });\r\n        var nestedRows = (_a = getChildRows(currentRow, rows)) === null || _a === void 0 ? void 0 : _a.map(function (childRow) { return ({\r\n            row: childRow,\r\n            level: level + 1,\r\n            leaf: !getChildRows(childRow, rows),\r\n        }); });\r\n        if (nestedRows) {\r\n            if (rowIndex > -1) {\r\n                treeRows.splice.apply(treeRows, __spread([rowIndex + 1, 0], nestedRows));\r\n            }\r\n            else {\r\n                treeRows.push.apply(treeRows, __spread(nestedRows));\r\n            }\r\n            rowsToProcess.push.apply(rowsToProcess, __spread(nestedRows));\r\n        }\r\n    };\r\n    while (rowsToProcess === null || rowsToProcess === void 0 ? void 0 : rowsToProcess.length) {\r\n        _loop_1();\r\n    }\r\n    var result = treeRows.reduce(function (acc, _a) {\r\n        var row = _a.row, level = _a.level, leaf = _a.leaf;\r\n        acc.rows.push(row);\r\n        acc.treeMeta.push([row, { level: level, leaf: leaf }]);\r\n        return acc;\r\n    }, { rows: [], treeMeta: [] });\r\n    return {\r\n        rows: result.rows,\r\n        treeMeta: new Map(result.treeMeta),\r\n    };\r\n};\r\nvar customTreeRowIdGetter = function (getRowId, _a) {\r\n    var rows = _a.rows, treeMeta = _a.treeMeta;\r\n    var firstNestedRowIndex = rows.findIndex(function (row) { return treeMeta.get(row).level > 0; });\r\n    if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {\r\n        return getRowId;\r\n    }\r\n    var map = new Map(rows\r\n        .map(function (row, rowIndex) { return [row, rowIndex]; }));\r\n    return function (row) { return map.get(row); };\r\n};\r\nvar customTreeRowLevelKeyGetter = function (getRowLevelKey, _a) {\r\n    var treeMeta = _a.treeMeta;\r\n    return function (row) {\r\n        var rowMeta = treeMeta.get(row);\r\n        if (rowMeta !== undefined) {\r\n            return GRID_TREE_NODE_TYPE.toString() + \"_\" + rowMeta.level;\r\n        }\r\n        return getRowLevelKey && getRowLevelKey();\r\n    };\r\n};\r\nvar expandedTreeRows = function (_a, getRowId, expandedRowIds) {\r\n    var rows = _a.rows, treeMeta = _a.treeMeta;\r\n    var expandedRowIdsSet = new Set(expandedRowIds);\r\n    var currentExpanded = true;\r\n    var currentLevel = 0;\r\n    var collapsedRowsMeta = new Map();\r\n    var resultRows = [];\r\n    rows.forEach(function (row) {\r\n        var rowMeta = treeMeta.get(row);\r\n        var level = rowMeta && rowMeta.level;\r\n        if (level === undefined && currentExpanded) {\r\n            resultRows.push(row);\r\n        }\r\n        else if (!currentExpanded && (level === undefined || level > currentLevel)) {\r\n            var lastRow = resultRows[resultRows.length - 1];\r\n            var collapsedItems = collapsedRowsMeta.get(lastRow);\r\n            if (!collapsedItems) {\r\n                collapsedItems = [];\r\n                collapsedRowsMeta.set(lastRow, collapsedItems);\r\n            }\r\n            collapsedItems.push(row);\r\n        }\r\n        else {\r\n            currentExpanded = expandedRowIdsSet.has(getRowId(row));\r\n            currentLevel = level;\r\n            resultRows.push(row);\r\n        }\r\n    });\r\n    return {\r\n        treeMeta: treeMeta,\r\n        collapsedRowsMeta: collapsedRowsMeta,\r\n        rows: resultRows,\r\n    };\r\n};\r\nvar collapsedTreeRowsGetter = function (getCollapsedRows, _a) {\r\n    var collapsedRowsMeta = _a.collapsedRowsMeta;\r\n    return function (row) { return collapsedRowsMeta.get(row) || (getCollapsedRows && getCollapsedRows(row)); };\r\n};\r\nvar isTreeRowLeafGetter = function (_a) {\r\n    var treeMeta = _a.treeMeta;\r\n    return function (row) {\r\n        var rowMeta = treeMeta.get(row);\r\n        return rowMeta && rowMeta.leaf;\r\n    };\r\n};\r\nvar getTreeRowLevelGetter = function (_a) {\r\n    var treeMeta = _a.treeMeta;\r\n    return function (row) {\r\n        var rowMeta = treeMeta.get(row);\r\n        return (rowMeta && rowMeta.level);\r\n    };\r\n};\r\nvar unwrappedCustomTreeRows = function (_a) {\r\n    var rows = _a.rows;\r\n    return rows;\r\n};\n\nvar isTreeTableCell = function (tableRow, tableColumn, forColumnName) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE\r\n    && tableColumn.column.name === forColumnName; };\n\nvar changeSearchValue = function (prevSearchValue, searchValue) { return searchValue; };\n\nvar searchFilterExpression = function (searchValue, columns, filterExpression) {\r\n    var filters = columns.map(function (_a) {\r\n        var name = _a.name;\r\n        return ({ columnName: name, value: searchValue });\r\n    });\r\n    var selfFilterExpression = { filters: filters, operator: 'or' };\r\n    if (!filterExpression) {\r\n        return selfFilterExpression;\r\n    }\r\n    return {\r\n        operator: 'and',\r\n        filters: [filterExpression, selfFilterExpression],\r\n    };\r\n};\n\nvar getAvailableFilterOperationsGetter = function (getAvailableFilterOperations, availableFilterOperations, columnNames) { return function (columnName) { return (columnNames.indexOf(columnName) > -1 && availableFilterOperations)\r\n    // tslint:disable-next-line: max-line-length\r\n    || (typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName))\r\n    || undefined; }; };\n\nvar FIXED_COLUMN_LEFT_SIDE = 'left';\r\nvar FIXED_COLUMN_RIGHT_SIDE = 'right';\r\nvar TABLE_FIXED_TYPE = Symbol('fixed');\n\nvar getFixedColumnKeys = function (tableColumns, fixedNames) { return tableColumns\r\n    .filter(function (tableColumn) { return ((tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column.name) !== -1)\r\n    || fixedNames.indexOf(tableColumn.type) !== -1); })\r\n    .map(function (_a) {\r\n    var key = _a.key;\r\n    return key;\r\n}); };\r\nvar isFixedTableRow = function (tableRow) { return tableRow.type === TABLE_FIXED_TYPE; };\r\nvar calculatePosition = function (array, index, tableColumnDimensions) { return (index === 0\r\n    ? 0\r\n    : array\r\n        .slice(0, index)\r\n        .reduce(function (acc, target) { return acc + tableColumnDimensions[target] || 0; }, 0)); };\r\nvar calculateFixedColumnProps = function (_a, _b, tableColumns, tableColumnDimensions, tableHeaderColumnChains) {\r\n    var tableColumn = _a.tableColumn;\r\n    var leftColumns = _b.leftColumns, rightColumns = _b.rightColumns;\r\n    var side = tableColumn.fixed;\r\n    var targetArray = side === FIXED_COLUMN_LEFT_SIDE\r\n        ? getFixedColumnKeys(tableColumns, leftColumns)\r\n        : (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.slice)(getFixedColumnKeys(tableColumns, rightColumns)).reverse();\r\n    var index = tableColumns.findIndex(function (_a) {\r\n        var key = _a.key;\r\n        return key === tableColumn.key;\r\n    });\r\n    var fixedIndex = targetArray.indexOf(tableColumn.key);\r\n    var columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index);\r\n    var showLeftDivider = columnChain.start === index && index !== 0;\r\n    var showRightDivider = columnChain.start + columnChain.columns.length - 1 === index\r\n        && index < tableColumns.length - 1;\r\n    var position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);\r\n    return {\r\n        showRightDivider: showRightDivider,\r\n        showLeftDivider: showLeftDivider,\r\n        position: position,\r\n        side: side,\r\n    };\r\n};\n\nvar tableColumnsWithFixed = function (tableColumns, leftColumns, rightColumns) { return tableColumns\r\n    .map(function (tableColumn) {\r\n    var fixed;\r\n    if ((tableColumn.type === TABLE_DATA_TYPE\r\n        && leftColumns.indexOf(tableColumn.column.name) !== -1)\r\n        || leftColumns.indexOf(tableColumn.type) !== -1) {\r\n        fixed = FIXED_COLUMN_LEFT_SIDE;\r\n    }\r\n    if ((tableColumn.type === TABLE_DATA_TYPE\r\n        && rightColumns.indexOf(tableColumn.column.name) !== -1)\r\n        || rightColumns.indexOf(tableColumn.type) !== -1) {\r\n        fixed = FIXED_COLUMN_RIGHT_SIDE;\r\n    }\r\n    return fixed ? __assign(__assign({}, tableColumn), { fixed: fixed }) : tableColumn;\r\n}); };\r\nvar tableHeaderRowsWithFixed = function (tableHeaderRows) { return __spread(tableHeaderRows, [\r\n    { key: TABLE_FIXED_TYPE.toString(), type: TABLE_FIXED_TYPE, height: 0 },\r\n]); };\r\nvar tableHeaderColumnChainsWithFixed = function (tableHeaderColumnChains, tableHeaderRows, tableColumns) {\r\n    var chains = tableHeaderColumnChains\r\n        || generateSimpleChains(tableHeaderRows, tableColumns);\r\n    var shouldSplitChain = function (currentGroup, column) { return (!currentGroup || currentGroup.fixed !== column.fixed); };\r\n    var extendChainProps = function (column) { return ({\r\n        fixed: column.fixed,\r\n    }); };\r\n    return splitHeaderColumnChains(chains, tableColumns, shouldSplitChain, extendChainProps);\r\n};\n\nvar defaultSummaryCalculators = {\r\n    count: function (rows) { return rows.length; },\r\n    sum: function (rows, getValue) { return rows.reduce(function (acc, row) { return acc + getValue(row); }, 0); },\r\n    max: function (rows, getValue) { return (rows.length\r\n        ? rows.reduce(function (acc, row) { return Math.max(acc, getValue(row)); }, -Infinity)\r\n        : null); },\r\n    min: function (rows, getValue) { return (rows.length\r\n        ? rows.reduce(function (acc, row) { return Math.min(acc, getValue(row)); }, Infinity)\r\n        : null); },\r\n    avg: function (rows, getValue) { return (rows.length\r\n        ? rows.reduce(function (acc, row) { return acc + getValue(row); }, 0) / rows.length\r\n        : null); },\r\n};\r\nvar defaultSummaryCalculator = function (type, rows, getValue) {\r\n    var summaryCalculator = defaultSummaryCalculators[type];\r\n    if (!summaryCalculator) {\r\n        throw new Error(\"The summary type '\" + type + \"' is not defined\");\r\n    }\r\n    return summaryCalculator(rows, getValue);\r\n};\r\nvar rowsSummary = function (rows, summaryItems, getCellValue, calculator) { return summaryItems\r\n    .reduce(function (acc, _a) {\r\n    var type = _a.type, columnName = _a.columnName;\r\n    var getValue = function (row) { return getCellValue(row, columnName); };\r\n    acc.push(calculator(type, rows, getValue));\r\n    return acc;\r\n}, []); };\r\nvar expandRows = function (rows, getRowLevelKey, getCollapsedRows, isGroupRow, includeGroupRow) {\r\n    if (includeGroupRow === void 0) { includeGroupRow = false; }\r\n    var shouldIncludeRow = includeGroupRow || !isGroupRow\r\n        ? function () { return true; }\r\n        : function (row) { return !isGroupRow(row); };\r\n    return rows\r\n        .reduce(function (acc, row) {\r\n        if (getRowLevelKey && getRowLevelKey(row)) {\r\n            if (shouldIncludeRow(row)) {\r\n                acc.push(row);\r\n            }\r\n            var collapsedRows = getCollapsedRows && getCollapsedRows(row);\r\n            if (collapsedRows) {\r\n                acc.push.apply(acc, __spread(collapsedRows));\r\n            }\r\n            return acc;\r\n        }\r\n        acc.push(row);\r\n        return acc;\r\n    }, []);\r\n};\r\nvar totalSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {\r\n    if (calculator === void 0) { calculator = defaultSummaryCalculator; }\r\n    var plainRows = expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow);\r\n    return rowsSummary(plainRows, summaryItems, getCellValue, calculator);\r\n};\r\nvar groupSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {\r\n    if (calculator === void 0) { calculator = defaultSummaryCalculator; }\r\n    var levels = [];\r\n    var getLevelIndex = function (levelKey) { return (levels.findIndex(function (level) { return level.levelKey === levelKey; })); };\r\n    var summaries = {};\r\n    var anyRowLevelSummaryExist = summaryItems.some(function (item) { return (!item.showInGroupFooter); });\r\n    var expandedRows = anyRowLevelSummaryExist\r\n        ? expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, true)\r\n        : rows;\r\n    expandedRows.forEach(function (row) {\r\n        var levelKey = getRowLevelKey(row);\r\n        var collapsedRows = getCollapsedRows && getCollapsedRows(row);\r\n        var levelIndex = getLevelIndex(levelKey);\r\n        if (levelIndex > -1) {\r\n            levels.forEach(function (level) {\r\n                summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\r\n            });\r\n            levels = levels.slice(0, levelIndex);\r\n        }\r\n        if (isGroupRow(row)) {\r\n            levels.push({\r\n                levelKey: levelKey,\r\n                row: row,\r\n                rows: [],\r\n            });\r\n            levelIndex = getLevelIndex(levelKey);\r\n        }\r\n        // when row level summary exists, these rows had already been expanded earlier\r\n        var isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;\r\n        var rowsToAppend = !levelKey ? [row] : collapsedRows;\r\n        if (!levelKey || isCollapsedNestedGroupRow) {\r\n            levels.forEach(function (level) {\r\n                var _a;\r\n                (_a = level.rows).push.apply(_a, __spread(rowsToAppend));\r\n            });\r\n        }\r\n    }, {});\r\n    levels.forEach(function (level) {\r\n        summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\r\n    });\r\n    return summaries;\r\n};\r\nvar treeSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator) {\r\n    if (calculator === void 0) { calculator = defaultSummaryCalculator; }\r\n    var levels = [];\r\n    var summaries = {};\r\n    rows.forEach(function (row) {\r\n        var levelKey = getRowLevelKey(row);\r\n        if (!levelKey) {\r\n            levels[levels.length - 1].rows.push(row);\r\n            return;\r\n        }\r\n        var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });\r\n        if (levelIndex > -1) {\r\n            levels.slice(levelIndex).forEach(function (level) {\r\n                if (level.rows.length) {\r\n                    summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\r\n                }\r\n            });\r\n            levels = levels.slice(0, levelIndex);\r\n        }\r\n        if (!isGroupRow || !isGroupRow(row)) {\r\n            if (levels.length) {\r\n                levels[levels.length - 1].rows.push(row);\r\n            }\r\n            levels.push({\r\n                levelKey: levelKey,\r\n                row: row,\r\n                rows: [],\r\n            });\r\n        }\r\n    }, {});\r\n    levels.forEach(function (level) {\r\n        if (level.rows.length) {\r\n            summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\r\n        }\r\n    });\r\n    return summaries;\r\n};\n\nvar TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');\r\nvar TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');\r\nvar TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');\r\nvar defaultFormatlessSummaries = ['count'];\n\nvar isTotalSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };\r\nvar isGroupSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };\r\nvar isTreeSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };\r\nvar isTotalSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TOTAL_SUMMARY_TYPE); };\r\nvar isGroupSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_GROUP_SUMMARY_TYPE); };\r\nvar isTreeSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TREE_SUMMARY_TYPE); };\r\nvar getColumnSummaries = function (summaryItems, columnName, summaryValues, predicate) {\r\n    if (predicate === void 0) { predicate = function () { return true; }; }\r\n    return summaryItems\r\n        .map(function (item, index) { return [item, index]; })\r\n        .filter(function (_a) {\r\n        var _b = __read(_a, 1), item = _b[0];\r\n        return item.columnName === columnName && predicate(item);\r\n    })\r\n        .map(function (_a) {\r\n        var _b = __read(_a, 2), item = _b[0], index = _b[1];\r\n        return ({\r\n            type: item.type,\r\n            value: summaryValues[index],\r\n        });\r\n    });\r\n};\r\nvar isFooterSummary = function (summaryItem) { return (summaryItem.showInGroupFooter); };\r\nvar isInlineGroupCaptionSummary = function (summaryItem) { return (!(summaryItem.showInGroupFooter ||\r\n    summaryItem.alignByColumn)); };\r\nvar groupFooterSummaryExists = function (groupSummaryItems) { return groupSummaryItems === null || groupSummaryItems === void 0 ? void 0 : groupSummaryItems.some(isFooterSummary); };\r\nvar getGroupInlineSummaries = function (summaryItems, columns, summaryValues) {\r\n    if (!summaryItems.some(isInlineGroupCaptionSummary)) {\r\n        return [];\r\n    }\r\n    return columns.reduce(function (acc, column) {\r\n        var colName = column.name;\r\n        var summaries = getColumnSummaries(summaryItems, colName, summaryValues, isInlineGroupCaptionSummary);\r\n        if (summaries.length) {\r\n            acc.push({\r\n                column: column,\r\n                summaries: summaries,\r\n            });\r\n        }\r\n        return acc;\r\n    }, []);\r\n};\n\nvar tableRowsWithTotalSummaries = function (footerRows) { return __spread([\r\n    { key: TABLE_TOTAL_SUMMARY_TYPE.toString(), type: TABLE_TOTAL_SUMMARY_TYPE }\r\n], footerRows); };\r\nvar tableRowsWithSummaries = function (tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId) {\r\n    var hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);\r\n    if (!getRowLevelKey || !(hasGroupFooterSummary || treeSummaryItems.length))\r\n        return tableRows;\r\n    var result = [];\r\n    var closeLevel = function (level) {\r\n        if (!level.opened)\r\n            return;\r\n        if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {\r\n            var compoundKey = level.row.compoundKey;\r\n            result.push({\r\n                key: TABLE_GROUP_SUMMARY_TYPE.toString() + \"_\" + compoundKey,\r\n                type: TABLE_GROUP_SUMMARY_TYPE,\r\n                row: level.row,\r\n            });\r\n        }\r\n        else if (treeSummaryItems.length) {\r\n            var rowId = getRowId(level.row);\r\n            result.push({\r\n                key: TABLE_TREE_SUMMARY_TYPE.toString() + \"_\" + rowId,\r\n                type: TABLE_TREE_SUMMARY_TYPE,\r\n                row: level.row,\r\n            });\r\n        }\r\n    };\r\n    var levels = [];\r\n    tableRows.forEach(function (tableRow) {\r\n        var row = tableRow.row;\r\n        var levelKey = getRowLevelKey(row);\r\n        if (levelKey) {\r\n            var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });\r\n            if (levelIndex > -1) {\r\n                levels.slice(levelIndex).reverse().forEach(closeLevel);\r\n                levels = levels.slice(0, levelIndex);\r\n            }\r\n            if (!isGroupRow || !isGroupRow(row)) {\r\n                levels = levels.map(function (level) { return (__assign(__assign({}, level), { opened: true })); });\r\n            }\r\n            levels.push({\r\n                levelKey: levelKey,\r\n                row: row,\r\n                opened: false,\r\n            });\r\n        }\r\n        else {\r\n            levels = levels.map(function (level) { return (__assign(__assign({}, level), { opened: true })); });\r\n        }\r\n        result.push(tableRow);\r\n    });\r\n    levels.slice().reverse().forEach(closeLevel);\r\n    return result;\r\n};\n\nvar prepareGroupSummaryItems = function (items) { return (!!items\r\n    ? items.map(function (item) { return (__assign(__assign({}, item), { showInGroupFooter: (item.showInGroupFooter === undefined && !item.alignByColumn)\r\n            ? true\r\n            : item.showInGroupFooter })); })\r\n    : items); };\n\nvar getTargetColumnGeometries = function (columnGeometries, sourceIndex) {\r\n    var sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;\r\n    var getWidthDifference = function (index) { return columnGeometries[index].right\r\n        - columnGeometries[index].left\r\n        - sourceWidth; };\r\n    return columnGeometries\r\n        .map(function (_a, targetIndex) {\r\n        var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;\r\n        var leftBorder = left;\r\n        if (targetIndex > 0 && targetIndex <= sourceIndex) {\r\n            leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));\r\n        }\r\n        if (targetIndex > sourceIndex) {\r\n            leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));\r\n        }\r\n        var rightBorder = right;\r\n        if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {\r\n            rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));\r\n        }\r\n        if (targetIndex < sourceIndex) {\r\n            rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));\r\n        }\r\n        return {\r\n            top: top,\r\n            bottom: bottom,\r\n            right: rightBorder,\r\n            left: leftBorder,\r\n        };\r\n    });\r\n};\r\nvar getCellGeometries = function (node) {\r\n    var _a, _b;\r\n    var _c = node.getBoundingClientRect(), left = _c.left, right = _c.right, width = _c.width;\r\n    var styleLeft = parseInt((_a = node.style.left) === null || _a === void 0 ? void 0 : _a.toString().replace('px', ''), 10);\r\n    var styleRight = parseInt((_b = node.style.right) === null || _b === void 0 ? void 0 : _b.toString().replace('px', ''), 10);\r\n    if (!isNaN(styleLeft)) {\r\n        var calculatedLeft = Math.max(styleLeft, left);\r\n        return {\r\n            left: calculatedLeft,\r\n            right: calculatedLeft + width,\r\n            isFixed: true,\r\n        };\r\n    }\r\n    if (!isNaN(styleRight)) {\r\n        // NOTE: get tableContainer (parent of first DIV element) to calculate 'right' value\r\n        var tableContainer = node;\r\n        while (tableContainer && tableContainer.nodeName !== 'DIV') {\r\n            tableContainer = tableContainer.parentNode;\r\n        }\r\n        tableContainer = tableContainer === null || tableContainer === void 0 ? void 0 : tableContainer.parentNode;\r\n        if (tableContainer) {\r\n            var tableWidth = tableContainer.getBoundingClientRect().width;\r\n            var calculatedRight = Math.min(tableWidth - styleRight, right);\r\n            return {\r\n                left: calculatedRight - width,\r\n                right: calculatedRight,\r\n                isFixed: true,\r\n            };\r\n        }\r\n    }\r\n    return { left: left, right: right };\r\n};\n\nvar getTableColumnGeometries = function (columns, tableWidth) {\r\n    var columnWidths = columns\r\n        .map(function (column) { return column.width; });\r\n    var freeSpace = tableWidth;\r\n    var restrictedSpace = columnWidths\r\n        .reduce(function (accum, width) { return accum + (typeof width === 'number' ? width : 0); }, 0);\r\n    var freeSpacePortions = columnWidths\r\n        .reduce(function (accum, width) { return accum + (typeof width !== 'number' ? 1 : 0); }, 0);\r\n    var freeSpacePortion = (freeSpace - restrictedSpace) / freeSpacePortions;\r\n    var lastRightPosition = 0;\r\n    return columnWidths\r\n        .map(function (width) { return (typeof width !== 'number' ? freeSpacePortion : width); })\r\n        .map(function (width) {\r\n        lastRightPosition += width;\r\n        return {\r\n            left: lastRightPosition - width,\r\n            right: lastRightPosition,\r\n        };\r\n    });\r\n};\r\nvar getTableTargetColumnIndex = function (columnGeometries, offset) {\r\n    var indexes = columnGeometries.reduce(function (acc, _a, index) {\r\n        var left = _a.left, right = _a.right;\r\n        if (offset > left && offset < right) {\r\n            acc.push(index);\r\n        }\r\n        return acc;\r\n    }, []);\r\n    if (indexes.length === 2) {\r\n        return indexes.find(function (index) { return columnGeometries[index].isFixed; });\r\n    }\r\n    if (indexes.length === 1) {\r\n        return indexes[0];\r\n    }\r\n    return -1;\r\n};\r\nvar ANIMATION_DURATION = 200;\r\nvar getAnimationProgress = function (animation) { return (new Date().getTime() - animation.startTime) / ANIMATION_DURATION; };\r\nvar getAnimations = function (prevColumns, nextColumns, tableWidth, prevAnimations) {\r\n    var resizing = prevColumns.map(function (column) { return column.key; }).join()\r\n        === nextColumns.map(function (column) { return column.key; }).join();\r\n    var prevColumnGeometries = new Map(getTableColumnGeometries(prevColumns, tableWidth)\r\n        .map(function (geometry, index) { return [prevColumns[index].key, geometry]; })\r\n        .map(function (_a) {\r\n        var _b = __read(_a, 2), key = _b[0], geometry = _b[1];\r\n        var animation = prevAnimations.get(key);\r\n        if (!animation)\r\n            return [key, geometry];\r\n        var progress = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.easeOutCubic)(getAnimationProgress(animation));\r\n        var _c = animation.left, to = _c.to, from = _c.from;\r\n        var left = ((to - from) * progress) + from;\r\n        return [key, {\r\n                left: left,\r\n                right: geometry.right - (geometry.left - left),\r\n            }];\r\n        // tslint:disable-next-line:array-type\r\n    }));\r\n    var nextColumnGeometries = new Map(getTableColumnGeometries(nextColumns, tableWidth)\r\n        // tslint:disable-next-line:array-type\r\n        .map(function (geometry, index) { return [nextColumns[index].key, geometry]; }));\r\n    return new Map(__spread(nextColumnGeometries.keys()).map(function (key) {\r\n        var prev = prevColumnGeometries.get(key);\r\n        var next = nextColumnGeometries.get(key);\r\n        var result = { startTime: new Date().getTime(), style: {} };\r\n        var takePrevColumnIntoAccount = !!prevAnimations.get(key) || (prev && !resizing);\r\n        if (Math.abs((takePrevColumnIntoAccount ? prev.left : next.left) - next.left) > 1) {\r\n            result.left = { from: prev.left, to: next.left };\r\n        }\r\n        return [key, result];\r\n    })\r\n        .filter(function (animation) { return animation[1].left; }));\r\n};\r\nvar filterActiveAnimations = function (animations) { return new Map(__spread(animations.entries()).filter(function (_a) {\r\n    var _b = __read(_a, 2), animation = _b[1];\r\n    return getAnimationProgress(animation) < 1;\r\n})); };\r\nvar evalAnimations = function (animations) { return new Map(__spread(animations.entries()).map(function (_a) {\r\n    var _b = __read(_a, 2), key = _b[0], animation = _b[1];\r\n    var progress = (0,_devexpress_dx_core__WEBPACK_IMPORTED_MODULE_0__.easeOutCubic)(getAnimationProgress(animation));\r\n    var result = __assign({}, animation.style);\r\n    if (animation.left) {\r\n        var offset = (animation.left.to - animation.left.from) * (progress - 1);\r\n        result.transform = \"translateX(\" + offset + \"px)\";\r\n    }\r\n    return [key, result];\r\n})); };\n\nvar isOnTheSameLine = function (geometry, y) { return (y >= geometry.top && y <= geometry.bottom); };\r\nvar rectToObject = function (_a) {\r\n    var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;\r\n    return ({\r\n        top: top, right: right, bottom: bottom, left: left,\r\n    });\r\n};\r\nvar collapseGapsBetweenItems = function (geometries) { return (geometries.map(function (geometry, index) {\r\n    if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {\r\n        return __assign(__assign({}, geometry), { right: geometries[index + 1].left });\r\n    }\r\n    return geometry;\r\n})); };\r\nvar getGroupCellTargetIndex = function (geometries, sourceIndex, _a) {\r\n    var x = _a.x, y = _a.y;\r\n    if (geometries.length === 0)\r\n        return 0;\r\n    var targetGeometries = sourceIndex !== -1\r\n        ? getTargetColumnGeometries(geometries, sourceIndex)\r\n        : geometries.map(rectToObject);\r\n    var targetIndex = collapseGapsBetweenItems(targetGeometries)\r\n        .findIndex(function (geometry, index) {\r\n        var inVerticalBounds = isOnTheSameLine(geometry, y);\r\n        var inHorizontalBounds = x >= geometry.left && x <= geometry.right;\r\n        var shouldGoFirst = index === 0 && x < geometry.left;\r\n        var shouldGoOnLineBreak = !inVerticalBounds\r\n            && !!geometries[index - 1]\r\n            && isOnTheSameLine(geometries[index - 1], y);\r\n        return (inVerticalBounds && inHorizontalBounds)\r\n            || shouldGoFirst\r\n            || shouldGoOnLineBreak;\r\n    });\r\n    return targetIndex === -1 ? geometries.length : targetIndex;\r\n};\n\n/** @internal */\r\nvar arraysEqual = function (arrA, arrB, comparator) {\r\n    if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }\r\n    if (arrA.length !== arrB.length) {\r\n        return false;\r\n    }\r\n    for (var i = 0; i < arrA.length; i += 1) {\r\n        if (!comparator(arrA[i], arrB[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\n\n/** @internal */\r\nvar emptyViewport = {\r\n    columns: [[0, 0]],\r\n    rows: [0, 0],\r\n    headerRows: [0, 0],\r\n    footerRows: [0, 0],\r\n    top: 0,\r\n    left: 0,\r\n    width: 800,\r\n    height: 600,\r\n};\r\nvar TOP_POSITION = Symbol('top');\r\nvar BOTTOM_POSITION = Symbol('bottom');\n\nvar VALID_UNITS$2 = ['px', ''];\r\n/* tslint:disable max-line-length */\r\nvar VIRTUAL_TABLE_ERROR = 'The columnExtension property of the VirtualTable plugin is given an invalid value.';\r\nvar getViewport = function (state, getters, estimatedRowHeight, getRowHeight, getColumnWidth) {\r\n    var viewportTop = state.viewportTop, viewportLeft = state.viewportLeft, containerWidth = state.containerWidth, containerHeight = state.containerHeight, headerHeight = state.headerHeight, footerHeight = state.footerHeight;\r\n    var loadedRowsStart = getters.loadedRowsStart, tableBodyRows = getters.bodyRows, tableColumns = getters.columns, _a = getters.headerRows, tableHeaderRows = _a === void 0 ? [] : _a, _b = getters.footerRows, tableFooterRows = _b === void 0 ? [] : _b, isDataRemote = getters.isDataRemote, viewport = getters.viewport;\r\n    var rows = getRowsVisibleBoundary(tableBodyRows, viewportTop, containerHeight - headerHeight - footerHeight, getRowHeight, loadedRowsStart, estimatedRowHeight, isDataRemote);\r\n    var headerRows = getRowsVisibleBoundary(tableHeaderRows, 0, headerHeight, getRowHeight, 0, estimatedRowHeight, false);\r\n    var footerRows = getRowsVisibleBoundary(tableFooterRows, 0, footerHeight, getRowHeight, 0, estimatedRowHeight, false);\r\n    var columns = getColumnBoundaries(tableColumns, viewportLeft, containerWidth, getColumnWidth);\r\n    // NOTE: prevent unnecessary updates\r\n    // e.g. when rows changed but bounds remain the same.\r\n    var result = viewport;\r\n    if (viewportTop !== viewport.top) {\r\n        result = __assign(__assign({}, result), { top: viewportTop });\r\n    }\r\n    if (viewportLeft !== viewport.left) {\r\n        result = __assign(__assign({}, result), { left: viewportLeft });\r\n    }\r\n    if (containerWidth !== viewport.width) {\r\n        result = __assign(__assign({}, result), { width: containerWidth });\r\n    }\r\n    if (containerHeight !== viewport.height) {\r\n        result = __assign(__assign({}, result), { height: containerHeight });\r\n    }\r\n    if (!arraysEqual(rows, viewport.rows)) {\r\n        result = __assign(__assign({}, result), { rows: rows });\r\n    }\r\n    if (!arraysEqual(headerRows, viewport.headerRows)) {\r\n        result = __assign(__assign({}, result), { headerRows: headerRows });\r\n    }\r\n    if (!arraysEqual(footerRows, viewport.footerRows)) {\r\n        result = __assign(__assign({}, result), { footerRows: footerRows });\r\n    }\r\n    if (!arraysEqual(columns, viewport.columns, arraysEqual)) {\r\n        result = __assign(__assign({}, result), { columns: columns });\r\n    }\r\n    return result;\r\n};\r\nvar checkColumnWidths = function (tableColumns) {\r\n    return tableColumns.reduce(function (acc, tableColumn) {\r\n        var width = tableColumn.width;\r\n        if (typeof width === 'string') {\r\n            var numb = parseInt(width, 10);\r\n            var unit_1 = numb ? width.substr(numb.toString().length) : width;\r\n            var isValidUnit = VALID_UNITS$2.some(function (validUnit) { return validUnit === unit_1; });\r\n            if (!isValidUnit) {\r\n                throw new Error(VIRTUAL_TABLE_ERROR);\r\n            }\r\n            acc.push(__assign(__assign({}, tableColumn), { width: numb }));\r\n        }\r\n        else {\r\n            acc.push(tableColumn);\r\n        }\r\n        return acc;\r\n    }, []);\r\n};\r\nvar calculateScrollHeight = function (rowHeight, index) {\r\n    return index > -1 ? rowHeight * index : undefined;\r\n};\r\nvar getScrollTop = function (rows, rowsCount, rowId, rowHeight, isDataRemote) {\r\n    if (rowId === TOP_POSITION) {\r\n        return 0;\r\n    }\r\n    if (rowId === BOTTOM_POSITION) {\r\n        return rowsCount * rowHeight;\r\n    }\r\n    var searchIndexRequired = !isDataRemote && rowId !== undefined;\r\n    var indexById = searchIndexRequired\r\n        ? rows.findIndex(function (row) { return row.rowId === rowId; })\r\n        : undefined;\r\n    return calculateScrollHeight(rowHeight, indexById);\r\n};\r\nvar getTopRowId = function (viewport, tableBodyRows, isDataRemote) {\r\n    var hasViewportRows = viewport && viewport.rows;\r\n    var hasBodyRows = tableBodyRows && tableBodyRows.length;\r\n    if (hasViewportRows && hasBodyRows && !isDataRemote) {\r\n        var index = viewport.rows[0];\r\n        return index < tableBodyRows.length ? tableBodyRows[index].rowId : undefined;\r\n    }\r\n    return undefined;\r\n};\n\nvar virtualRowsWithCache = function (skip, rows, cache) {\r\n    var rowsInterval = intervalUtil.getRowsInterval({ skip: skip, rows: rows });\r\n    var cacheInterval = intervalUtil.getRowsInterval(cache);\r\n    return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);\r\n};\r\nvar plainRows = function (virtualRows, availableRowCount) {\r\n    return virtualRows.rows.length > availableRowCount\r\n        ? virtualRows.rows.slice(0, availableRowCount)\r\n        : virtualRows.rows;\r\n};\r\nvar loadedRowsStart = function (virtualRows) { return virtualRows.skip; };\n\nvar ROOT_GROUP = '__root__';\r\nvar DEFAULT_COLUMN_WIDTH = 150;\n\nvar exportHeader = function (worksheet, columns) {\r\n    var cols = columns\r\n        .map(function (_a) {\r\n        var column = _a.column, width = _a.width;\r\n        return ({\r\n            width: (width || DEFAULT_COLUMN_WIDTH) / 8,\r\n            key: column === null || column === void 0 ? void 0 : column.name,\r\n        });\r\n    });\r\n    worksheet.columns = cols;\r\n    var headerRow = columns.reduce(function (acc, _a) {\r\n        var _b;\r\n        var _c = _a.column, _d = _c === void 0 ? {} : _c, name = _d.name, title = _d.title;\r\n        return (__assign(__assign({}, acc), (_b = {}, _b[name] = title, _b)));\r\n    }, {});\r\n    worksheet.addRow(headerRow);\r\n    worksheet.views.push({\r\n        state: 'frozen',\r\n        ySplit: worksheet.lastRow.number,\r\n    });\r\n};\r\nvar findRanges = function (groupTree, compoundKey, level, maxLevel, result) {\r\n    if (result === void 0) { result = []; }\r\n    if (level !== maxLevel) {\r\n        var ranges = groupTree[compoundKey].reduce(function (acc, groupKey) { return (__spread(acc, findRanges(groupTree, groupKey, level + 1, maxLevel, result))); }, []);\r\n        return __spread(result, ranges);\r\n    }\r\n    return __spread(result, [groupTree[compoundKey]]);\r\n};\r\nvar exportRows = function (worksheet, allRows, dataColumns, columns, isGroupRow, outlineLevels, rowsOffset, getCellValue, getCloseGroup, customizeCell) {\r\n    var currentLevel = 0;\r\n    var openGroups = [];\r\n    var closeGroup = getCloseGroup(rowsOffset);\r\n    allRows.forEach(function (row) {\r\n        var _a;\r\n        var _b;\r\n        var excelRow;\r\n        if (isGroupRow && isGroupRow(row)) {\r\n            currentLevel = outlineLevels[row.groupedBy];\r\n            // close nested groups first\r\n            openGroups.slice(currentLevel).reverse().forEach(closeGroup);\r\n            openGroups = openGroups.slice(0, currentLevel);\r\n            openGroups[currentLevel] = { groupedBy: row.groupedBy, compoundKey: row.compoundKey };\r\n            // add group row\r\n            var title = (_b = dataColumns.find(function (_a) {\r\n                var name = _a.name;\r\n                return name === row.groupedBy;\r\n            })) === null || _b === void 0 ? void 0 : _b.title;\r\n            excelRow = (_a = {}, _a[columns[0].column.name] = title + \": \" + row.value, _a);\r\n            worksheet.addRow(excelRow);\r\n            var lastIndex = worksheet.lastRow.number;\r\n            // merge into single cell\r\n            worksheet.mergeCells(lastIndex, 1, lastIndex, columns.length);\r\n            worksheet.lastRow.getCell(1).font = { bold: true };\r\n            if (currentLevel > 0) {\r\n                worksheet.lastRow.outlineLevel = currentLevel;\r\n            }\r\n            currentLevel += 1;\r\n        }\r\n        else {\r\n            excelRow = columns.reduce(function (acc, _a) {\r\n                var _b;\r\n                var column = _a.column;\r\n                return (__assign(__assign({}, acc), (column ? (_b = {}, _b[column.name] = getCellValue(row, column.name), _b) : null)));\r\n            }, {});\r\n            worksheet.addRow(excelRow);\r\n            worksheet.lastRow.outlineLevel = currentLevel;\r\n        }\r\n        worksheet.lastRow.eachCell(function (cell, colNumber) {\r\n            customizeCell(cell, row, columns[colNumber - 1].column);\r\n        });\r\n    });\r\n    openGroups.reverse().forEach(closeGroup);\r\n};\r\nvar closeSheet = function (worksheet, groupTree, maxGroupLevel, rowsOffset, totalSummaryItems, exportSummary) {\r\n    exportSummaryItems(worksheet, groupTree, totalSummaryItems, ROOT_GROUP, -1, rowsOffset, maxGroupLevel, exportSummary);\r\n};\r\nvar normalizeRanges = function (ranges, offset) { return (ranges.map(function (range) { return range.map(function (index) { return +index + offset; }); })); };\r\nvar exportSummaryItems = function (worksheet, groupTree, summaryItems, groupKey, groupLevel, rowsOffset, maxGroupLevel, exportSummary) {\r\n    if (!summaryItems)\r\n        return;\r\n    worksheet.addRow({});\r\n    var ranges = normalizeRanges(findRanges(groupTree, groupKey, groupLevel, maxGroupLevel), rowsOffset);\r\n    summaryItems.forEach(function (s) {\r\n        exportSummary(s, ranges);\r\n    });\r\n};\r\nvar removeEmptyGroups = function (rows, grouping, isGroupRow) {\r\n    if (!grouping)\r\n        return rows;\r\n    var groupingColumns = grouping.map(function (_a) {\r\n        var columnName = _a.columnName;\r\n        return columnName;\r\n    });\r\n    var result = [];\r\n    var groupChain = [];\r\n    rows.forEach(function (row) {\r\n        if (isGroupRow(row)) {\r\n            var level = groupingColumns.indexOf(row.groupedBy);\r\n            if (level === groupChain.length) {\r\n                groupChain.push(row);\r\n            }\r\n            else {\r\n                groupChain = __spread(groupChain.slice(0, level), [row]);\r\n            }\r\n        }\r\n        else {\r\n            if (groupChain.length > 0) {\r\n                result.push.apply(result, __spread(groupChain));\r\n                groupChain = Array.from({ length: groupChain.length });\r\n            }\r\n            result.push(row);\r\n        }\r\n    });\r\n    return result.filter(function (row) { return !!row; });\r\n};\n\nvar groupOutlineLevels = function (grouping) { return ((grouping === null || grouping === void 0 ? void 0 : grouping.reduce(function (acc, _a, index) {\r\n    var _b;\r\n    var columnName = _a.columnName;\r\n    return (__assign(__assign({}, acc), (_b = {}, _b[columnName] = index, _b)));\r\n}, {})) || {}); };\r\nvar filterSelectedRows = function (rows, selection, getRowId, isGroupRow) {\r\n    var selectionSet = new Set(selection);\r\n    return rows.filter(function (row) { return (isGroupRow && isGroupRow(row)) || selectionSet.has(getRowId(row)); });\r\n};\r\nvar rowsToExport = function (rows, selection, grouping, getCollapsedRows, getRowId, isGroupRow) {\r\n    var expandRows = function (collapsedRows) { return (collapsedRows.reduce(function (acc, row) { return (__spread(acc, [row], (expandRows(getCollapsedRows(row) || [])))); }, [])); };\r\n    var expandedRows = getCollapsedRows ? expandRows(rows) : rows;\r\n    if (!selection) {\r\n        return expandedRows;\r\n    }\r\n    var filteredRows = filterSelectedRows(expandedRows, selection, getRowId, isGroupRow);\r\n    return removeEmptyGroups(filteredRows, grouping, isGroupRow);\r\n};\r\nvar buildGroupTree = function (rows, outlineLevels, grouping, isGroupRow, groupSummaryItems) {\r\n    var _a;\r\n    var groupTree = (_a = {}, _a[ROOT_GROUP] = [], _a);\r\n    if (!(grouping === null || grouping === void 0 ? void 0 : grouping.length)) {\r\n        groupTree[ROOT_GROUP] = [0, rows.length - 1];\r\n        return groupTree;\r\n    }\r\n    var maxLevel = Object.keys(outlineLevels).length - 1;\r\n    var groupSummaryExists = !!groupSummaryItems;\r\n    var parentChain = { '-1': ROOT_GROUP };\r\n    var lastDataIndex = 0;\r\n    var openGroup = '';\r\n    var index = 0;\r\n    var level = 0;\r\n    var prevLevel = 0;\r\n    rows.forEach(function (row) {\r\n        var groupedBy = row.groupedBy, compoundKey = row.compoundKey;\r\n        if (isGroupRow(row)) {\r\n            level = outlineLevels[groupedBy];\r\n            groupTree[compoundKey] = [];\r\n            parentChain[level] = compoundKey;\r\n            if (level <= maxLevel) {\r\n                groupTree[parentChain[level - 1]].push(compoundKey);\r\n            }\r\n            if (level === maxLevel) {\r\n                if (openGroup) {\r\n                    // close previous group\r\n                    groupTree[openGroup].push(lastDataIndex);\r\n                }\r\n                openGroup = compoundKey;\r\n                if (groupSummaryExists && lastDataIndex > 0) {\r\n                    index += 1;\r\n                }\r\n                groupTree[compoundKey].push(index + 1); // first row index\r\n            }\r\n            else if (groupSummaryExists && level < prevLevel) {\r\n                // jump over summary rows\r\n                index += maxLevel - level;\r\n            }\r\n            prevLevel = level;\r\n        }\r\n        else {\r\n            lastDataIndex = index;\r\n        }\r\n        index += 1;\r\n    });\r\n    if (openGroup) {\r\n        groupTree[openGroup].push(lastDataIndex);\r\n    }\r\n    return groupTree;\r\n};\r\nvar operations = {\r\n    count: 'COUNTA',\r\n};\r\nvar exportSummaryGetter = function (worksheet, tableColumns, customizeSummaryCell, defaultSummaryMessages) { return function (_a, ranges) {\r\n    var columnName = _a.columnName, type = _a.type;\r\n    var column = (tableColumns.find(function (_a) {\r\n        var dataColumn = _a.column, columnType = _a.type;\r\n        return (columnType === TABLE_DATA_TYPE && dataColumn && dataColumn.name === columnName);\r\n    }) || {}).column;\r\n    // NOTE: column is hidden or the grid grouped by this column\r\n    if (!column) {\r\n        return;\r\n    }\r\n    var row = worksheet.lastRow;\r\n    var letter = worksheet.getColumn(columnName).letter;\r\n    var operation = operations[type] || type.toUpperCase();\r\n    var rangesStr = ranges.map(function (range) { return (range\r\n        .map(function (r) { return \"\" + letter + r; })\r\n        .filter(function (val, index, arr) { return arr.indexOf(val) === index; })\r\n        .join(':')); }).join(',');\r\n    var cell = row.getCell(columnName);\r\n    cell.value = {\r\n        formula: operation + \"(\" + rangesStr + \")\",\r\n        date1904: false,\r\n    };\r\n    cell.numFmt = \"\\\"\" + defaultSummaryMessages[type] + \":\\\" 0\";\r\n    var summary = {\r\n        type: type,\r\n        ranges: ranges,\r\n    };\r\n    customizeSummaryCell(cell, column, summary);\r\n}; };\r\nvar closeGroupGetter = function (worksheet, groupTree, outlineLevels, maxGroupLevel, groupSummaryItems, exportSummary) { return function (rowsOffset) { return function (group) {\r\n    var groupedBy = group.groupedBy, compoundKey = group.compoundKey;\r\n    exportSummaryItems(worksheet, groupTree, groupSummaryItems, compoundKey, outlineLevels[groupedBy], rowsOffset, maxGroupLevel, exportSummary);\r\n}; }; };\r\nvar maximumGroupLevel = function (grouping) { return ((grouping || []).length - 1); };\n\n\n//# sourceMappingURL=dx-grid-core.es.js.map\n\n\n//# sourceURL=webpack://front-end/./node_modules/@devexpress/dx-grid-core/dist/dx-grid-core.es.js?");

/***/ })

}]);